[{"path":"https://nacnudus.github.io/unpivotr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 unpivotr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"rowspan-and-colspan-examples","dir":"Articles","previous_headings":"","what":"Rowspan and colspan examples","title":"HTML Tables","text":"table cells merged across rows columns (), as_cells() attempt fill cell contents across rows columns. different packages, e.g. rvest. However, merged cells cause table square, as_cells() pads missing cells blanks.","code":""},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"rowspan","dir":"Articles","previous_headings":"Rowspan and colspan examples","what":"Rowspan","title":"HTML Tables","text":"","code":"rowspan <- system.file(\"extdata\", \"rowspan.html\", package = \"unpivotr\") includeHTML(rowspan) # rvest rowspan %>%   read_html() %>%   html_table() ## [[1]] ## # A tibble: 1 × 2 ##   `Header (1:2, 1)` `Header (1, 2)` ##   <chr>             <chr>           ## 1 Header (1:2, 1)   cell (2, 2) # unpivotr rowspan %>%   read_html() %>%   as_cells() ## [[1]] ## # A tibble: 4 × 4 ##     row   col data_type html                                     ##   <int> <int> <chr>     <chr>                                    ## 1     1     1 html      \"<th rowspan=\\\"2\\\">Header (1:2, 1)<\/th>\" ## 2     2     1 html       NA                                      ## 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                 ## 4     2     2 html      \"<td>cell (2, 2)<\/td>\""},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"colspan","dir":"Articles","previous_headings":"Rowspan and colspan examples","what":"Colspan","title":"HTML Tables","text":"","code":"colspan <- system.file(\"extdata\", \"colspan.html\", package = \"unpivotr\") includeHTML(colspan) # rvest colspan %>%   read_html() %>%   html_table() ## [[1]] ## # A tibble: 1 × 2 ##   `Header (1, 1:2)` `Header (1, 1:2)` ##   <chr>             <chr>             ## 1 cell (2, 1)       cell (2, 2) # unpivotr colspan %>%   read_html() %>%   as_cells() ## [[1]] ## # A tibble: 4 × 4 ##     row   col data_type html                                     ##   <int> <int> <chr>     <chr>                                    ## 1     1     1 html      \"<th colspan=\\\"2\\\">Header (1, 1:2)<\/th>\" ## 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                   ## 3     1     2 html       NA                                      ## 4     2     2 html      \"<td>cell (2, 2)<\/td>\""},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"both-rowspan-and-colspan-non-square","dir":"Articles","previous_headings":"Rowspan and colspan examples","what":"Both rowspan and colspan: non-square","title":"HTML Tables","text":"","code":"rowandcolspan <- system.file(\"extdata\",                              \"row-and-colspan.html\",                              package = \"unpivotr\") includeHTML(rowandcolspan) # rvest rowandcolspan %>%   read_html() %>%   html_table() ## [[1]] ## # A tibble: 1 × 5 ##   `Header (1:2, 1:2)` `Header (1:2, 1:2)` `Header (2, 3)` ``          ``         ##   <chr>               <chr>               <chr>           <chr>       <chr>      ## 1 Header (1:2, 1:2)   Header (1:2, 1:2)   cell (3, 1)     cell (3, 2) cell (3, … # unpivotr rowandcolspan %>%   read_html() %>%   as_cells() ## [[1]] ## # A tibble: 10 × 4 ##      row   col data_type html                                                    ##    <int> <int> <chr>     <chr>                                                   ##  1     1     1 html      \"<th colspan=\\\"2\\\" rowspan=\\\"2\\\">Header (1:2, 1:2)<\/th… ##  2     2     1 html       NA                                                     ##  3     1     2 html       NA                                                     ##  4     2     2 html       NA                                                     ##  5     1     3 html      \"<th>Header (2, 3)<\/th>\"                                ##  6     2     3 html      \"<td>cell (3, 1)<\/td>\"                                  ##  7     1     4 html       NA                                                     ##  8     2     4 html      \"<td>cell (3, 2)<\/td>\"                                  ##  9     1     5 html       NA                                                     ## 10     2     5 html      \"<td>cell (3, 3)<\/td>\""},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"nested-example","dir":"Articles","previous_headings":"","what":"Nested example","title":"HTML Tables","text":"as_cells() never descends cells. table inside cell, parse table use html_table cell.","code":"nested <- system.file(\"extdata\", \"nested.html\", package = \"unpivotr\") includeHTML(nested) # rvest parses both tables nested %>%   read_html() %>%   html_table(fill = TRUE) ## [[1]] ## # A tibble: 3 × 6 ##   `Header (1, 1)`     `Header (1, 2)`                    ``    ``    ``    ``    ##   <chr>               <chr>                              <chr> <chr> <chr> <chr> ## 1 cell (2, 1)         \"Header (2, 2)(1, 1)\\n           … Head… Head… cell… cell… ## 2 Header (2, 2)(1, 1) \"Header (2, 2)(1, 2)\"              NA    NA    NA    NA    ## 3 cell (2, 2)(2, 1)   \"cell (2, 2)(2, 1)\"                NA    NA    NA    NA    ##  ## [[2]] ## # A tibble: 1 × 2 ##   `Header (2, 2)(1, 1)` `Header (2, 2)(1, 2)` ##   <chr>                 <chr>                 ## 1 cell (2, 2)(2, 1)     cell (2, 2)(2, 1) # unpivotr x <-   nested %>%   read_html() %>%   as_cells() %>%   .[[1]] x ## # A tibble: 4 × 4 ##     row   col data_type html                                                     ##   <int> <int> <chr>     <chr>                                                    ## 1     1     1 html      \"<th>Header (1, 1)<\/th>\"                                 ## 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                                   ## 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                                 ## 4     2     2 html      \"<td>\\n          <table>\\n<tr>\\n<th>Header (2, 2)(1, 1)… # The html of the table inside a cell cell <-   x %>%   dplyr::filter(row == 2, col == 2) %>%   .$html cell ## [1] \"<td>\\n          <table>\\n<tr>\\n<th>Header (2, 2)(1, 1)<\/th>\\n              <th>Header (2, 2)(1, 2)<\/th>\\n            <\/tr>\\n<tr>\\n<td>cell (2, 2)(2, 1)<\/td>\\n              <td>cell (2, 2)(2, 1)<\/td>\\n            <\/tr>\\n<\/table>\\n<\/td>\" # Parsing the table inside the cell cell %>%   read_html() %>%   as_cells() ## [[1]] ## # A tibble: 4 × 4 ##     row   col data_type html                         ##   <int> <int> <chr>     <chr>                        ## 1     1     1 html      <th>Header (2, 2)(1, 1)<\/th> ## 2     2     1 html      <td>cell (2, 2)(2, 1)<\/td>   ## 3     1     2 html      <th>Header (2, 2)(1, 2)<\/th> ## 4     2     2 html      <td>cell (2, 2)(2, 1)<\/td>"},{"path":"https://nacnudus.github.io/unpivotr/articles/html.html","id":"url-example","dir":"Articles","previous_headings":"","what":"URL example","title":"HTML Tables","text":"motivation using unpivotr::as_cells() extracts just text – can extract whatever part HTML need. , extract URLs.","code":"urls <- system.file(\"extdata\", \"url.html\", package = \"unpivotr\") includeHTML(urls) cell_url <- function(x) {   if (is.na(x)) return(NA)   x %>%     read_html %>%     html_nodes(\"a\") %>%     html_attr(\"href\") }  cell_text <- function(x) {   if (is.na(x)) return(NA)   x %>%     read_html %>%     html_nodes(\"a\") %>%     html_text() }  urls %>%   read_html() %>%   as_cells() %>%   .[[1]] %>%   mutate(text = purrr::map(html, cell_text),          url = purrr::map(html, cell_url)) %>%   tidyr::unnest(text, url) ## Warning: `unnest()` has a new interface. See `?unnest` for details. ## ℹ Try `df %>% unnest(c(text, url))`, with `mutate()` if needed. ## # A tibble: 8 × 6 ##     row   col data_type html                                         text  url   ##   <int> <int> <chr>     <chr>                                        <chr> <chr> ## 1     1     1 html      \"<td colspan=\\\"2\\\">\\n<a href=\\\"https://www.… Scra… http… ## 2     1     1 html      \"<td colspan=\\\"2\\\">\\n<a href=\\\"https://www.… HTML. http… ## 3     2     1 html      \"<td><a href=\\\"https://cran.r-project.org/\\… Sweet http… ## 4     1     2 html       NA                                          NA    NA    ## 5     2     2 html      \"<td><a href=\\\"https://cran.r-project.org/p… as?   http… ## 6     1     3 html       NA                                          NA    NA    ## 7     2     3 html      \"<td>\\n<a href=\\\"https://cran.r-project.org… Yeah, http… ## 8     2     3 html      \"<td>\\n<a href=\\\"https://cran.r-project.org… righ… http…"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"preface","dir":"Articles","previous_headings":"","what":"Preface","title":"Introduction to unpivotr","text":"based talk. might want watch video read slides (see speaker notes clicking cog): https://docs.google.com/presentation/d/1tVwn_-QVGZTflnF9APiPACNvyAKqujdl6JmxmrdDjok","code":""},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"reading-easy-spreadsheets-with-readxl","dir":"Articles","previous_headings":"","what":"1. Reading easy spreadsheets with {readxl}","title":"Introduction to unpivotr","text":"easy read spreadsheet R : rectangular shape One row column headers meaningful colour formatting Consistent data types column, e.g. numbers text example, dataset student test marks different subjects.  test whether table easy import, ask “every row self-sufficient? read one row understand data ?” case, one row tell Ron got two marks potions second year. table simple – ‘tidy’ – easily imported data frame, using {readxl} package. Note row column names spreadsheet used column names data frame. Also data type column either dbl (double, means number), chr (character) appropriate.","code":"library(readxl) # for read_excel()  hp_xlsx <- system.file(\"extdata/harry-potter.xlsx\", package = \"unpivotr\")  tidy <- read_excel(hp_xlsx, sheet = \"tidy\")  tidy #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 8 × 4 #>   Pupil Year     Subject    Mark #>   <chr> <chr>    <chr>     <dbl> #> 1 Ron   1st year Potions       3 #> 2 Ron   1st year Herbology     7 #> 3 Ron   2nd year Potions       2 #> 4 Ron   2nd year Herbology    10 #> 5 Ginny 1st year Potions       8 #> 6 Ginny 1st year Herbology     9 #> 7 Ginny 2nd year Potions       9 #> 8 Ginny 2nd year Herbology     7"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"trying-to-read-a-hard-spreadsheet-with-readxl","dir":"Articles","previous_headings":"","what":"2. Trying to read a hard spreadsheet with {readxl}","title":"Introduction to unpivotr","text":"’s data time spreadsheet {readxl} package can’t read easily. ?  Pupil Year columns combined one, names pupils aren’t rows marks, columns. also text value \"10 - really?\" amongst column numbers. every row self-sufficient? read one row understand data ? , one row tell mark, subject year, name. else tell name, mark, subject year. happens table read {readxl} package. gone wrong? spreadsheet broken assumptions {readxl} package makes data. rectangular shape. spreadsheet rectangular top-left cell deliberately blank (‘missing’ data), cells right \"Ron\" \"Ginny\". meaningful colour formatting. spreadsheet meaningful formatting distinguish names bold (\"Ron\", \"Ginny\") years plain type, (\"1st year\", \"2nd year\"). Consistent data types column. spreadsheet mixed data types Herbology column, cells numbers one text: \"10 -   really?\". readxl package done best difficult file. dealt non-rectangular shape filling gaps, using ...1 fill cell top-left corner column header, NA fill cells right Ron Ginny. dealt mixed data types Herbology column treating everything text, even numbers, can accommodate text value \"10 - really?\". hasn’t dealt meaningful formatting (bold names) blind formatting – {readxl} doesn’t know anything formatting except data types. Unfortunately {readxl} hasn’t able make data tidy. row still isn’t self-sufficient. couldn’t read one row understand data . final example spreadsheet breaks one remaining assumption: single row column headers. file two rows column headers.  rest tutorial demonstrate use {tidyxl} {unpivotr} packages import spreadsheet.","code":"untidy <- read_excel(hp_xlsx, sheet = \"untidy\") #> New names: #> • `` -> `...1`  untidy #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 6 × 3 #>   ...1     Potions Herbology    #>   <chr>      <dbl> <chr>        #> 1 Ron           NA NA           #> 2 1st year       3 7            #> 3 2nd year       2 10 - really? #> 4 Ginny         NA NA           #> 5 1st year       8 9            #> 6 2nd year       9 7"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"demonstration-of-tidyxl-and-unpivotr","dir":"Articles","previous_headings":"","what":"3. Demonstration of {tidyxl} and {unpivotr}","title":"Introduction to unpivotr","text":"Don’t expect understand yet following code works. show expect later, entire code import spreadsheet .","code":"library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(tidyr) library(tidyxl) library(unpivotr) #>  #> Attaching package: 'unpivotr' #> The following objects are masked from 'package:tidyr': #>  #>     pack, unpack  hp_xlsx <- system.file(\"extdata/harry-potter.xlsx\", package = \"unpivotr\")  cells <- xlsx_cells(hp_xlsx, sheets = \"pivoted\") formats <- xlsx_formats(hp_xlsx)  indent <- formats$local$alignment$indent  tidied <-   cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0,             direction = \"left-up\",             name = \"location\") %>%   behead(\"left\", \"subject\") %>%   select(address, dormitory, name, location, subject, mark = numeric) %>%   arrange(dormitory, name, location, subject)  tidied #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 24 × 6 #>    address dormitory name     location subject                    mark #>    <chr>   <chr>     <chr>    <chr>    <chr>                     <dbl> #>  1 C4      Witch     Ginny    Castle   Charms                        6 #>  2 C5      Witch     Ginny    Castle   Potions                       5 #>  3 C3      Witch     Ginny    Castle   NA                           11 #>  4 C8      Witch     Ginny    Grounds  Care of Magical Creatures     7 #>  5 C7      Witch     Ginny    Grounds  Herbology                     1 #>  6 C6      Witch     Ginny    Grounds  NA                            8 #>  7 B4      Witch     Hermione Castle   Charms                        2 #>  8 B5      Witch     Hermione Castle   Potions                       9 #>  9 B3      Witch     Hermione Castle   NA                           11 #> 10 B8      Witch     Hermione Grounds  Care of Magical Creatures     2 #> 11 B7      Witch     Hermione Grounds  Herbology                     5 #> 12 B6      Witch     Hermione Grounds  NA                            7 #> 13 D4      Wizard    Harry    Castle   Charms                        0 #> 14 D5      Wizard    Harry    Castle   Potions                       7 #> 15 D3      Wizard    Harry    Castle   NA                            7 #> 16 D8      Wizard    Harry    Grounds  Care of Magical Creatures     3 #> 17 D7      Wizard    Harry    Grounds  Herbology                     8 #> 18 D6      Wizard    Harry    Grounds  NA                           11 #> 19 E4      Wizard    Ron      Castle   Charms                        0 #> 20 E5      Wizard    Ron      Castle   Potions                       2 #> 21 E3      Wizard    Ron      Castle   NA                            2 #> 22 E8      Wizard    Ron      Grounds  Care of Magical Creatures     3 #> 23 E7      Wizard    Ron      Grounds  Herbology                    NA #> 24 E6      Wizard    Ron      Grounds  NA                            3"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"explanation-of-tidyxlxlsx_cells","dir":"Articles","previous_headings":"","what":"4. Explanation of tidyxl::xlsx_cells()","title":"Introduction to unpivotr","text":"first step import difficult spreadsheet read tidyxl::xlsx_cells(). tidyxl::xlsx_cells() different readxl::read_excel()? Instead returning data data frame, returns individual cells data frame. Try matching row output xlsx_cells() cell spreadsheet. first row output describes cell B2 (row 1, column 2) spreadsheet, character value \"Witch\". Row 10 describes cell C3 (row 3, column 3) spreadsheet, numeric value 11. xlsx_cells() done give data frame isn’t data , describes data spreadsheet. row describes one cell. allows fancy tricks, like filter numeric cells. filter particular cell row column position. can filter ‘blank’ cells. cell ‘blank’ formatting value. Sometimes ’s useful , usually discard . need know tidyxl package now. Later shown filter cells formatting (e.g. bold cells, indented cells, cells coloured text).","code":"cells <-   xlsx_cells(hp_xlsx, sheets = \"pivoted\") %>%   # Drop some columns to make it clearer what is going on   select(row, col, is_blank, data_type, character, numeric, local_format_id)  cells #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 47 × 7 #>      row   col is_blank data_type character              numeric local_format_id #>    <int> <int> <lgl>    <chr>     <chr>                    <dbl>           <int> #>  1     1     2 FALSE    character Witch                       NA               2 #>  2     1     4 FALSE    character Wizard                      NA               2 #>  3     2     1 TRUE     blank     NA                          NA               9 #>  4     2     2 FALSE    character Hermione                    NA               3 #>  5     2     3 FALSE    character Ginny                       NA               4 #>  6     2     4 FALSE    character Harry                       NA               3 #>  7     2     5 FALSE    character Ron                         NA               4 #>  8     3     1 FALSE    character Castle                      NA              12 #>  9     3     2 FALSE    numeric   NA                          11               5 #> 10     3     3 FALSE    numeric   NA                          11               6 #> 11     3     4 FALSE    numeric   NA                           7               5 #> 12     3     5 FALSE    numeric   NA                           2               6 #> 13     4     1 FALSE    character Charms                      NA              10 #> 14     4     2 FALSE    numeric   NA                           2               2 #> 15     4     3 FALSE    numeric   NA                           6               1 #> 16     4     4 FALSE    numeric   NA                           0               2 #> 17     4     5 FALSE    numeric   NA                           0               1 #> 18     5     1 FALSE    character Potions                     NA              11 #> 19     5     2 FALSE    numeric   NA                           9               3 #> 20     5     3 FALSE    numeric   NA                           5               4 #> 21     5     4 FALSE    numeric   NA                           7               3 #> 22     5     5 FALSE    numeric   NA                           2               4 #> 23     6     1 FALSE    character Grounds                     NA              12 #> 24     6     2 FALSE    numeric   NA                           7               5 #> 25     6     3 FALSE    numeric   NA                           8               6 #> 26     6     4 FALSE    numeric   NA                          11               5 #> 27     6     5 FALSE    numeric   NA                           3               6 #> 28     7     1 FALSE    character Herbology                   NA              10 #> 29     7     2 FALSE    numeric   NA                           5               2 #> 30     7     3 FALSE    numeric   NA                           1               1 #> 31     7     4 FALSE    numeric   NA                           8               2 #> 32     7     5 FALSE    character 10 - really?                NA              13 #> 33     8     1 FALSE    character Care of Magical Creat…      NA              14 #> 34     8     2 FALSE    numeric   NA                           2              15 #> 35     8     3 FALSE    numeric   NA                           7              17 #> 36     8     4 FALSE    numeric   NA                           3              15 #> 37     8     5 FALSE    numeric   NA                           3              16 #> 38     9     1 TRUE     blank     NA                          NA              14 #> 39     9     2 TRUE     blank     NA                          NA              15 #> 40     9     3 TRUE     blank     NA                          NA              17 #> 41     9     4 TRUE     blank     NA                          NA              15 #> 42     9     5 TRUE     blank     NA                          NA              16 #> 43    10     1 TRUE     blank     NA                          NA              14 #> 44    10     2 TRUE     blank     NA                          NA              15 #> 45    10     3 TRUE     blank     NA                          NA              17 #> 46    10     4 TRUE     blank     NA                          NA              15 #> 47    10     5 TRUE     blank     NA                          NA              16 # A tibble: 47 x 7      row   col is_blank data_type character numeric local_format_id    <int> <int> <lgl>    <chr>     <chr>       <dbl>           <int>  1     1     2 FALSE    character Witch          NA               2 cells %>%   filter(data_type == \"numeric\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 23 × 7 #>      row   col is_blank data_type character numeric local_format_id #>    <int> <int> <lgl>    <chr>     <chr>       <dbl>           <int> #>  1     3     2 FALSE    numeric   NA             11               5 #>  2     3     3 FALSE    numeric   NA             11               6 #>  3     3     4 FALSE    numeric   NA              7               5 #>  4     3     5 FALSE    numeric   NA              2               6 #>  5     4     2 FALSE    numeric   NA              2               2 #>  6     4     3 FALSE    numeric   NA              6               1 #>  7     4     4 FALSE    numeric   NA              0               2 #>  8     4     5 FALSE    numeric   NA              0               1 #>  9     5     2 FALSE    numeric   NA              9               3 #> 10     5     3 FALSE    numeric   NA              5               4 #> 11     5     4 FALSE    numeric   NA              7               3 #> 12     5     5 FALSE    numeric   NA              2               4 #> 13     6     2 FALSE    numeric   NA              7               5 #> 14     6     3 FALSE    numeric   NA              8               6 #> 15     6     4 FALSE    numeric   NA             11               5 #> 16     6     5 FALSE    numeric   NA              3               6 #> 17     7     2 FALSE    numeric   NA              5               2 #> 18     7     3 FALSE    numeric   NA              1               1 #> 19     7     4 FALSE    numeric   NA              8               2 #> 20     8     2 FALSE    numeric   NA              2              15 #> 21     8     3 FALSE    numeric   NA              7              17 #> 22     8     4 FALSE    numeric   NA              3              15 #> 23     8     5 FALSE    numeric   NA              3              16 cells %>%   filter(row == 2, col == 4) #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 1 × 7 #>     row   col is_blank data_type character numeric local_format_id #>   <int> <int> <lgl>    <chr>     <chr>       <dbl>           <int> #> 1     2     4 FALSE    character Harry          NA               3 cells %>%   filter(!is_blank) #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 36 × 7 #>      row   col is_blank data_type character              numeric local_format_id #>    <int> <int> <lgl>    <chr>     <chr>                    <dbl>           <int> #>  1     1     2 FALSE    character Witch                       NA               2 #>  2     1     4 FALSE    character Wizard                      NA               2 #>  3     2     2 FALSE    character Hermione                    NA               3 #>  4     2     3 FALSE    character Ginny                       NA               4 #>  5     2     4 FALSE    character Harry                       NA               3 #>  6     2     5 FALSE    character Ron                         NA               4 #>  7     3     1 FALSE    character Castle                      NA              12 #>  8     3     2 FALSE    numeric   NA                          11               5 #>  9     3     3 FALSE    numeric   NA                          11               6 #> 10     3     4 FALSE    numeric   NA                           7               5 #> 11     3     5 FALSE    numeric   NA                           2               6 #> 12     4     1 FALSE    character Charms                      NA              10 #> 13     4     2 FALSE    numeric   NA                           2               2 #> 14     4     3 FALSE    numeric   NA                           6               1 #> 15     4     4 FALSE    numeric   NA                           0               2 #> 16     4     5 FALSE    numeric   NA                           0               1 #> 17     5     1 FALSE    character Potions                     NA              11 #> 18     5     2 FALSE    numeric   NA                           9               3 #> 19     5     3 FALSE    numeric   NA                           5               4 #> 20     5     4 FALSE    numeric   NA                           7               3 #> 21     5     5 FALSE    numeric   NA                           2               4 #> 22     6     1 FALSE    character Grounds                     NA              12 #> 23     6     2 FALSE    numeric   NA                           7               5 #> 24     6     3 FALSE    numeric   NA                           8               6 #> 25     6     4 FALSE    numeric   NA                          11               5 #> 26     6     5 FALSE    numeric   NA                           3               6 #> 27     7     1 FALSE    character Herbology                   NA              10 #> 28     7     2 FALSE    numeric   NA                           5               2 #> 29     7     3 FALSE    numeric   NA                           1               1 #> 30     7     4 FALSE    numeric   NA                           8               2 #> 31     7     5 FALSE    character 10 - really?                NA              13 #> 32     8     1 FALSE    character Care of Magical Creat…      NA              14 #> 33     8     2 FALSE    numeric   NA                           2              15 #> 34     8     3 FALSE    numeric   NA                           7              17 #> 35     8     4 FALSE    numeric   NA                           3              15 #> 36     8     5 FALSE    numeric   NA                           3              16"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"explanation-of-unpivotrbehead","dir":"Articles","previous_headings":"","what":"5. Explanation of unpivotr::behead()","title":"Introduction to unpivotr","text":"’ve seen tidyxl::xlsx_cells() reads spreadsheet one cell time, can filter particular cells position, value, data type, etc. now write code tidy spreadsheet. unpivotr package gives pre-packaged tools tidying spreadsheet. important tool behead(), deals one layer header cells time. Let’s look original spreadsheet. highlighted first row header cells.  Use unpivotr::behead() tag data cells \"Witch\" \"Wizard\", strip (behead!) header cells rest – longer required. Click table check every cell belonging Witch header taggged \"Witch\" column dormitory, wizards Notice locations Castle Grounds also tagged witch wizard. Also, cells row 1 disappeared – become values dormitory column. arguments behead(\"-left\", \"dormitory\") mean? second one, \"dormitory\" becomes column name male/female tags. direction \"-left\" important one. tells behead() way look header cell. example, starting cell C3 (row 3 column 3), behead() looks left find header \"Witch\". Starting cell D4 (row 4, column 4) finds header \"Wizard\". Starting cells first column, header cell \"-left\" direction, tagged missing values. Don’t worry – come right later. try different direction instead, \"-right\" (right)? , compare table spreadsheet  Check Ginny tagged \"Wizard\", marks cells . Unpivotr doesn’t know wrong, just done told. behead() function isn’t magic, just enables tell unpivotr data cells relate header cells.","code":"cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 34 × 8 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     2     2 FALSE    character Hermione          NA               3 Witch     #>  2     2     3 FALSE    character Ginny             NA               4 Witch     #>  3     3     2 FALSE    numeric   NA                11               5 Witch     #>  4     3     3 FALSE    numeric   NA                11               6 Witch     #>  5     4     2 FALSE    numeric   NA                 2               2 Witch     #>  6     4     3 FALSE    numeric   NA                 6               1 Witch     #>  7     5     2 FALSE    numeric   NA                 9               3 Witch     #>  8     5     3 FALSE    numeric   NA                 5               4 Witch     #>  9     6     2 FALSE    numeric   NA                 7               5 Witch     #> 10     6     3 FALSE    numeric   NA                 8               6 Witch     #> 11     7     2 FALSE    numeric   NA                 5               2 Witch     #> 12     7     3 FALSE    numeric   NA                 1               1 Witch     #> 13     8     2 FALSE    numeric   NA                 2              15 Witch     #> 14     8     3 FALSE    numeric   NA                 7              17 Witch     #> 15     2     4 FALSE    character Harry             NA               3 Wizard    #> 16     2     5 FALSE    character Ron               NA               4 Wizard    #> 17     3     4 FALSE    numeric   NA                 7               5 Wizard    #> 18     3     5 FALSE    numeric   NA                 2               6 Wizard    #> 19     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 20     4     5 FALSE    numeric   NA                 0               1 Wizard    #> 21     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 22     5     5 FALSE    numeric   NA                 2               4 Wizard    #> 23     6     4 FALSE    numeric   NA                11               5 Wizard    #> 24     6     5 FALSE    numeric   NA                 3               6 Wizard    #> 25     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 26     7     5 FALSE    character 10 - really?      NA              13 Wizard    #> 27     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 28     8     5 FALSE    numeric   NA                 3              16 Wizard    #> 29     3     1 FALSE    character Castle            NA              12 NA        #> 30     4     1 FALSE    character Charms            NA              10 NA        #> 31     5     1 FALSE    character Potions           NA              11 NA        #> 32     6     1 FALSE    character Grounds           NA              12 NA        #> 33     7     1 FALSE    character Herbology         NA              10 NA        #> 34     8     1 FALSE    character Care of Mag…      NA              14 NA cells %>%   filter(!is_blank) %>%   behead(\"up-right\", \"dormitory\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 34 × 8 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     2     2 FALSE    character Hermione          NA               3 Witch     #>  2     3     1 FALSE    character Castle            NA              12 Witch     #>  3     3     2 FALSE    numeric   NA                11               5 Witch     #>  4     4     1 FALSE    character Charms            NA              10 Witch     #>  5     4     2 FALSE    numeric   NA                 2               2 Witch     #>  6     5     1 FALSE    character Potions           NA              11 Witch     #>  7     5     2 FALSE    numeric   NA                 9               3 Witch     #>  8     6     1 FALSE    character Grounds           NA              12 Witch     #>  9     6     2 FALSE    numeric   NA                 7               5 Witch     #> 10     7     1 FALSE    character Herbology         NA              10 Witch     #> 11     7     2 FALSE    numeric   NA                 5               2 Witch     #> 12     8     1 FALSE    character Care of Mag…      NA              14 Witch     #> 13     8     2 FALSE    numeric   NA                 2              15 Witch     #> 14     2     3 FALSE    character Ginny             NA               4 Wizard    #> 15     2     4 FALSE    character Harry             NA               3 Wizard    #> 16     3     3 FALSE    numeric   NA                11               6 Wizard    #> 17     3     4 FALSE    numeric   NA                 7               5 Wizard    #> 18     4     3 FALSE    numeric   NA                 6               1 Wizard    #> 19     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 20     5     3 FALSE    numeric   NA                 5               4 Wizard    #> 21     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 22     6     3 FALSE    numeric   NA                 8               6 Wizard    #> 23     6     4 FALSE    numeric   NA                11               5 Wizard    #> 24     7     3 FALSE    numeric   NA                 1               1 Wizard    #> 25     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 26     8     3 FALSE    numeric   NA                 7              17 Wizard    #> 27     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 28     2     5 FALSE    character Ron               NA               4 NA        #> 29     3     5 FALSE    numeric   NA                 2               6 NA        #> 30     4     5 FALSE    numeric   NA                 0               1 NA        #> 31     5     5 FALSE    numeric   NA                 2               4 NA        #> 32     6     5 FALSE    numeric   NA                 3               6 NA        #> 33     7     5 FALSE    character 10 - really?      NA              13 NA        #> 34     8     5 FALSE    numeric   NA                 3              16 NA"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"continuing-unpivotrbehead","dir":"Articles","previous_headings":"","what":"6. Continuing unpivotr::behead()","title":"Introduction to unpivotr","text":"Let’s carry second row header cells (highlighted). time direction simply \"\" directly header every column. Notice ’re building pipeline transformations, one set headers time.  Click table match spreadsheet. header cells rows 1 2 disappeared become values dormitory name columns. cell C3 (row 3, column 3) tagged \"Witch\" \"Ginny\"","code":"cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 30 × 9 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     3     2 FALSE    numeric   NA                11               5 Witch     #>  2     3     3 FALSE    numeric   NA                11               6 Witch     #>  3     4     2 FALSE    numeric   NA                 2               2 Witch     #>  4     4     3 FALSE    numeric   NA                 6               1 Witch     #>  5     5     2 FALSE    numeric   NA                 9               3 Witch     #>  6     5     3 FALSE    numeric   NA                 5               4 Witch     #>  7     6     2 FALSE    numeric   NA                 7               5 Witch     #>  8     6     3 FALSE    numeric   NA                 8               6 Witch     #>  9     7     2 FALSE    numeric   NA                 5               2 Witch     #> 10     7     3 FALSE    numeric   NA                 1               1 Witch     #> 11     8     2 FALSE    numeric   NA                 2              15 Witch     #> 12     8     3 FALSE    numeric   NA                 7              17 Witch     #> 13     3     4 FALSE    numeric   NA                 7               5 Wizard    #> 14     3     5 FALSE    numeric   NA                 2               6 Wizard    #> 15     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 16     4     5 FALSE    numeric   NA                 0               1 Wizard    #> 17     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 18     5     5 FALSE    numeric   NA                 2               4 Wizard    #> 19     6     4 FALSE    numeric   NA                11               5 Wizard    #> 20     6     5 FALSE    numeric   NA                 3               6 Wizard    #> 21     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 22     7     5 FALSE    character 10 - really?      NA              13 Wizard    #> 23     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 24     8     5 FALSE    numeric   NA                 3              16 Wizard    #> 25     3     1 FALSE    character Castle            NA              12 NA        #> 26     4     1 FALSE    character Charms            NA              10 NA        #> 27     5     1 FALSE    character Potions           NA              11 NA        #> 28     6     1 FALSE    character Grounds           NA              12 NA        #> 29     7     1 FALSE    character Herbology         NA              10 NA        #> 30     8     1 FALSE    character Care of Mag…      NA              14 NA        #> # ℹ 1 more variable: name <chr>"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"handling-meaningful-formatting-with-unpivotrbehead_if","dir":"Articles","previous_headings":"","what":"7. Handling meaningful formatting with unpivotr::behead_if()","title":"Introduction to unpivotr","text":"Applying procedure headers column , describe location subject, directions? Starting data cell, say, B7 (row 7, column 2), location \"Grounds\", left , \"left-\".  complication. unpivotr::behead() travelling cells column 1, know stop \"Grounds\" overshoot \"Potions\" cells ? must tell behead() stop first cell isn’t indented. Alternatively, tell stop first cell bold. Use unpivotr::behead_if() rule identify header cell. case rule “cell bold formatting”. spreadsheet cell can many different formats unweildy {tidyxl} import . Instead, {tidyxl} imports kind lookup table formatting, cell key lookup table, called local_format_id. ’s look indented property cell. look format inside behead_if(), don’t need mention cell$, name arguments behead(). can give one rule behead_if() . applied together, rules must evaluate TRUE cell treated header cell. ’s example applying additional rule cell must bold. result case . Check Hermione got 5 marks subject taken Hogwarts grounds, looking cell B7 (row 7, column 2).","code":"formats <- xlsx_formats(hp_xlsx) # load the format lookup table from the file  indent <- formats$local$alignment$indent # find the 'indent' property  indent[cells$local_format_id] # look up the indent property of each cell #>  [1] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 #> [39] 0 0 0 0 1 0 0 0 0 formats <- xlsx_formats(hp_xlsx) # load the format lookup table from the file indent <- formats$local$alignment$indent # find the 'indent' property  cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0,             direction = \"left-up\", # This argument has to be named now.             name = \"location\")     # So does this one. #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 28 × 10 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     3     2 FALSE    numeric   NA                11               5 Witch     #>  2     3     3 FALSE    numeric   NA                11               6 Witch     #>  3     4     2 FALSE    numeric   NA                 2               2 Witch     #>  4     4     3 FALSE    numeric   NA                 6               1 Witch     #>  5     5     2 FALSE    numeric   NA                 9               3 Witch     #>  6     5     3 FALSE    numeric   NA                 5               4 Witch     #>  7     3     4 FALSE    numeric   NA                 7               5 Wizard    #>  8     3     5 FALSE    numeric   NA                 2               6 Wizard    #>  9     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 10     4     5 FALSE    numeric   NA                 0               1 Wizard    #> 11     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 12     5     5 FALSE    numeric   NA                 2               4 Wizard    #> 13     4     1 FALSE    character Charms            NA              10 NA        #> 14     5     1 FALSE    character Potions           NA              11 NA        #> 15     6     2 FALSE    numeric   NA                 7               5 Witch     #> 16     6     3 FALSE    numeric   NA                 8               6 Witch     #> 17     7     2 FALSE    numeric   NA                 5               2 Witch     #> 18     7     3 FALSE    numeric   NA                 1               1 Witch     #> 19     8     2 FALSE    numeric   NA                 2              15 Witch     #> 20     8     3 FALSE    numeric   NA                 7              17 Witch     #> 21     6     4 FALSE    numeric   NA                11               5 Wizard    #> 22     6     5 FALSE    numeric   NA                 3               6 Wizard    #> 23     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 24     7     5 FALSE    character 10 - really?      NA              13 Wizard    #> 25     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 26     8     5 FALSE    numeric   NA                 3              16 Wizard    #> 27     7     1 FALSE    character Herbology         NA              10 NA        #> 28     8     1 FALSE    character Care of Mag…      NA              14 NA        #> # ℹ 2 more variables: name <chr>, location <chr> formats <- xlsx_formats(hp_xlsx) indent <- formats$local$alignment$indent bold <- formats$local$font$bold # find the 'bold' property  cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0, # First rule             bold[local_format_id],        # Second rule. Both must be TRUE             direction = \"left-up\",             name = \"location\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 28 × 10 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     3     2 FALSE    numeric   NA                11               5 Witch     #>  2     3     3 FALSE    numeric   NA                11               6 Witch     #>  3     4     2 FALSE    numeric   NA                 2               2 Witch     #>  4     4     3 FALSE    numeric   NA                 6               1 Witch     #>  5     5     2 FALSE    numeric   NA                 9               3 Witch     #>  6     5     3 FALSE    numeric   NA                 5               4 Witch     #>  7     3     4 FALSE    numeric   NA                 7               5 Wizard    #>  8     3     5 FALSE    numeric   NA                 2               6 Wizard    #>  9     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 10     4     5 FALSE    numeric   NA                 0               1 Wizard    #> 11     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 12     5     5 FALSE    numeric   NA                 2               4 Wizard    #> 13     4     1 FALSE    character Charms            NA              10 NA        #> 14     5     1 FALSE    character Potions           NA              11 NA        #> 15     6     2 FALSE    numeric   NA                 7               5 Witch     #> 16     6     3 FALSE    numeric   NA                 8               6 Witch     #> 17     7     2 FALSE    numeric   NA                 5               2 Witch     #> 18     7     3 FALSE    numeric   NA                 1               1 Witch     #> 19     8     2 FALSE    numeric   NA                 2              15 Witch     #> 20     8     3 FALSE    numeric   NA                 7              17 Witch     #> 21     6     4 FALSE    numeric   NA                11               5 Wizard    #> 22     6     5 FALSE    numeric   NA                 3               6 Wizard    #> 23     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 24     7     5 FALSE    character 10 - really?      NA              13 Wizard    #> 25     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 26     8     5 FALSE    numeric   NA                 3              16 Wizard    #> 27     7     1 FALSE    character Herbology         NA              10 NA        #> 28     8     1 FALSE    character Care of Mag…      NA              14 NA        #> # ℹ 2 more variables: name <chr>, location <chr>"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"finishing-and-cleaning-up","dir":"Articles","previous_headings":"","what":"8. Finishing and cleaning up","title":"Introduction to unpivotr","text":"one layer headers remains: subjects column 1. direction directly \"left\".  Check Hermione got 5 marks Herbology particular, taken Hogwarts grounds, looking cell B7 (row 7, column 2). final cleanup straightforward; choose columns keep, using standard tidyverse function dplyr::select(). time can rename column numeric mark, column character . column ? value \"10 - really?\". now ‘total’ values castle grounds. don’t want keep , ’s easy enough filter using !.na(subject). done final code listing .","code":"cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0,             direction = \"left-up\",             name = \"location\") %>%   behead(\"left\", \"subject\") #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 24 × 11 #>      row   col is_blank data_type character    numeric local_format_id dormitory #>    <int> <int> <lgl>    <chr>     <chr>          <dbl>           <int> <chr>     #>  1     3     2 FALSE    numeric   NA                11               5 Witch     #>  2     3     3 FALSE    numeric   NA                11               6 Witch     #>  3     4     2 FALSE    numeric   NA                 2               2 Witch     #>  4     4     3 FALSE    numeric   NA                 6               1 Witch     #>  5     5     2 FALSE    numeric   NA                 9               3 Witch     #>  6     5     3 FALSE    numeric   NA                 5               4 Witch     #>  7     3     4 FALSE    numeric   NA                 7               5 Wizard    #>  8     3     5 FALSE    numeric   NA                 2               6 Wizard    #>  9     4     4 FALSE    numeric   NA                 0               2 Wizard    #> 10     4     5 FALSE    numeric   NA                 0               1 Wizard    #> 11     5     4 FALSE    numeric   NA                 7               3 Wizard    #> 12     5     5 FALSE    numeric   NA                 2               4 Wizard    #> 13     6     2 FALSE    numeric   NA                 7               5 Witch     #> 14     6     3 FALSE    numeric   NA                 8               6 Witch     #> 15     7     2 FALSE    numeric   NA                 5               2 Witch     #> 16     7     3 FALSE    numeric   NA                 1               1 Witch     #> 17     8     2 FALSE    numeric   NA                 2              15 Witch     #> 18     8     3 FALSE    numeric   NA                 7              17 Witch     #> 19     6     4 FALSE    numeric   NA                11               5 Wizard    #> 20     6     5 FALSE    numeric   NA                 3               6 Wizard    #> 21     7     4 FALSE    numeric   NA                 8               2 Wizard    #> 22     7     5 FALSE    character 10 - really?      NA              13 Wizard    #> 23     8     4 FALSE    numeric   NA                 3              15 Wizard    #> 24     8     5 FALSE    numeric   NA                 3              16 Wizard    #> # ℹ 3 more variables: name <chr>, location <chr>, subject <chr> cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0,             direction = \"left-up\",             name = \"location\") %>%   behead(\"left\", \"subject\") %>%   select(dormitory, name, location, subject, mark = numeric, other = character) #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 24 × 6 #>    dormitory name     location subject                    mark other        #>    <chr>     <chr>    <chr>    <chr>                     <dbl> <chr>        #>  1 Witch     Hermione Castle   NA                           11 NA           #>  2 Witch     Ginny    Castle   NA                           11 NA           #>  3 Witch     Hermione Castle   Charms                        2 NA           #>  4 Witch     Ginny    Castle   Charms                        6 NA           #>  5 Witch     Hermione Castle   Potions                       9 NA           #>  6 Witch     Ginny    Castle   Potions                       5 NA           #>  7 Wizard    Harry    Castle   NA                            7 NA           #>  8 Wizard    Ron      Castle   NA                            2 NA           #>  9 Wizard    Harry    Castle   Charms                        0 NA           #> 10 Wizard    Ron      Castle   Charms                        0 NA           #> 11 Wizard    Harry    Castle   Potions                       7 NA           #> 12 Wizard    Ron      Castle   Potions                       2 NA           #> 13 Witch     Hermione Grounds  NA                            7 NA           #> 14 Witch     Ginny    Grounds  NA                            8 NA           #> 15 Witch     Hermione Grounds  Herbology                     5 NA           #> 16 Witch     Ginny    Grounds  Herbology                     1 NA           #> 17 Witch     Hermione Grounds  Care of Magical Creatures     2 NA           #> 18 Witch     Ginny    Grounds  Care of Magical Creatures     7 NA           #> 19 Wizard    Harry    Grounds  NA                           11 NA           #> 20 Wizard    Ron      Grounds  NA                            3 NA           #> 21 Wizard    Harry    Grounds  Herbology                     8 NA           #> 22 Wizard    Ron      Grounds  Herbology                    NA 10 - really? #> 23 Wizard    Harry    Grounds  Care of Magical Creatures     3 NA           #> 24 Wizard    Ron      Grounds  Care of Magical Creatures     3 NA library(dplyr) library(tidyr) library(tidyxl) library(unpivotr)  hp_xlsx <- system.file(\"extdata/harry-potter.xlsx\", package = \"unpivotr\")  cells <- xlsx_cells(hp_xlsx, sheet = \"pivoted\") formats <- xlsx_formats(hp_xlsx)  indent <- formats$local$alignment$indent  tidied <-   cells %>%   filter(!is_blank) %>%   behead(\"up-left\", \"dormitory\") %>%   behead(\"up\", \"name\") %>%   behead_if(indent[local_format_id] == 0,             direction = \"left-up\",             name = \"location\") %>%   behead(\"left\", \"subject\") %>%   select(address, dormitory, name, location, subject, mark = numeric) %>%   arrange(dormitory, name, location, subject)  tidied #> Warning: `...` must be empty in `format.tbl()` #> Caused by error in `format_tbl()`: #> ! `...` must be empty. #> ✖ Problematic argument: #> • options = options #> # A tibble: 24 × 6 #>    address dormitory name     location subject                    mark #>    <chr>   <chr>     <chr>    <chr>    <chr>                     <dbl> #>  1 C4      Witch     Ginny    Castle   Charms                        6 #>  2 C5      Witch     Ginny    Castle   Potions                       5 #>  3 C3      Witch     Ginny    Castle   NA                           11 #>  4 C8      Witch     Ginny    Grounds  Care of Magical Creatures     7 #>  5 C7      Witch     Ginny    Grounds  Herbology                     1 #>  6 C6      Witch     Ginny    Grounds  NA                            8 #>  7 B4      Witch     Hermione Castle   Charms                        2 #>  8 B5      Witch     Hermione Castle   Potions                       9 #>  9 B3      Witch     Hermione Castle   NA                           11 #> 10 B8      Witch     Hermione Grounds  Care of Magical Creatures     2 #> 11 B7      Witch     Hermione Grounds  Herbology                     5 #> 12 B6      Witch     Hermione Grounds  NA                            7 #> 13 D4      Wizard    Harry    Castle   Charms                        0 #> 14 D5      Wizard    Harry    Castle   Potions                       7 #> 15 D3      Wizard    Harry    Castle   NA                            7 #> 16 D8      Wizard    Harry    Grounds  Care of Magical Creatures     3 #> 17 D7      Wizard    Harry    Grounds  Herbology                     8 #> 18 D6      Wizard    Harry    Grounds  NA                           11 #> 19 E4      Wizard    Ron      Castle   Charms                        0 #> 20 E5      Wizard    Ron      Castle   Potions                       2 #> 21 E3      Wizard    Ron      Castle   NA                            2 #> 22 E8      Wizard    Ron      Grounds  Care of Magical Creatures     3 #> 23 E7      Wizard    Ron      Grounds  Herbology                    NA #> 24 E6      Wizard    Ron      Grounds  NA                            3"},{"path":"https://nacnudus.github.io/unpivotr/articles/introduction.html","id":"review","dir":"Articles","previous_headings":"","what":"Review","title":"Introduction to unpivotr","text":"Well done making far. struggled follow, normal – means learning. Try reading second third time, change parts code see happens.","code":""},{"path":"https://nacnudus.github.io/unpivotr/articles/small-multiples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Small Multiples","text":"spreadsheet famous Enron subpoena, made available Felienne Hermans, previously publicised Jenny Bryan David Robinson, particular Robinson’s article ‘Tidying untidyable dataset’. ’s screenshot:","code":"knitr::include_graphics(\"enron-screenshot.png\")"},{"path":"https://nacnudus.github.io/unpivotr/articles/small-multiples.html","id":"preparation","dir":"Articles","previous_headings":"","what":"Preparation","title":"Small Multiples","text":"vignette uses several common packages. spreadsheet distributed unpivotr package, can loaded system file.","code":"library(unpivotr) library(tidyxl) library(dplyr) ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union library(purrr) library(tidyr) ##  ## Attaching package: 'tidyr' ## The following objects are masked from 'package:unpivotr': ##  ##     pack, unpack library(stringr) path <- system.file(\"extdata/enron.xlsx\", package = \"unpivotr\")"},{"path":[]},{"path":"https://nacnudus.github.io/unpivotr/articles/small-multiples.html","id":"importing-the-data","dir":"Articles","previous_headings":"Main","what":"Importing the data","title":"Small Multiples","text":"Spreadsheet cells imported xlsx_cells() function, returns data frame cells requested sheets. default, every sheet imported, don’t worry case one sheet file. can also straightaway discard rows 14 56, columns beyond 20. Cell formatting isn’t required vignette, , imported via xlsx_formats(path).","code":"cells <-   xlsx_cells(path) %>%   dplyr::filter(!is_blank, between(row, 14L, 56L), col <= 20) %>%   select(row, col, data_type, numeric, character, date) formatting <- xlsx_formats(path)"},{"path":"https://nacnudus.github.io/unpivotr/articles/small-multiples.html","id":"importing-one-of-the-multiples","dir":"Articles","previous_headings":"Main","what":"Importing one of the multiples","title":"Small Multiples","text":"small multiples exactly one ‘Fixed Price’ header cell, begin filtering cells, move selection one row get title cells. title cells top-left corner cell table. Use title cells partition sheet. Taking one partitions, unpivot behead(). compass directions \"NNW\" \"N\" express direction data cell header. \"NNW\" means “look left find nearest header.” procedure can mapped every small multiple. far, column headers joined, also row headers left-hand side spreadsheet. following code incorporates final dataset.","code":"title <-   dplyr::filter(cells, character == \"Fixed Price\") %>%   select(row, col) %>%   mutate(row = row - 1L) %>%   inner_join(cells, by = c(\"row\", \"col\")) partitions <- partition(cells, title) partitions$cells[[1]] %>%   behead(\"NNW\", \"title\") %>%   behead(\"NNW\", \"price\") %>%   behead(\"N\", \"bid_offer\") %>%   print(n = Inf) ## # A tibble: 24 × 9 ##      row   col data_type numeric character date   title                   price  ##    <int> <int> <chr>       <dbl> <chr>     <dttm> <chr>                   <chr>  ##  1    17    17 numeric     1.89  NA        NA     IF NWPL Rocky Mountains Fixed… ##  2    17    18 numeric     1.91  NA        NA     IF NWPL Rocky Mountains Fixed… ##  3    18    17 numeric     2.06  NA        NA     IF NWPL Rocky Mountains Fixed… ##  4    18    18 numeric     2.08  NA        NA     IF NWPL Rocky Mountains Fixed… ##  5    19    17 numeric     2.40  NA        NA     IF NWPL Rocky Mountains Fixed… ##  6    19    18 numeric     2.42  NA        NA     IF NWPL Rocky Mountains Fixed… ##  7    20    17 numeric     2.59  NA        NA     IF NWPL Rocky Mountains Fixed… ##  8    20    18 numeric     2.61  NA        NA     IF NWPL Rocky Mountains Fixed… ##  9    21    17 numeric     2.58  NA        NA     IF NWPL Rocky Mountains Fixed… ## 10    21    18 numeric     2.60  NA        NA     IF NWPL Rocky Mountains Fixed… ## 11    22    17 numeric     3.36  NA        NA     IF NWPL Rocky Mountains Fixed… ## 12    22    18 numeric     3.38  NA        NA     IF NWPL Rocky Mountains Fixed… ## 13    23    17 numeric     2.63  NA        NA     IF NWPL Rocky Mountains Fixed… ## 14    23    18 numeric     2.65  NA        NA     IF NWPL Rocky Mountains Fixed… ## 15    19    19 numeric    -0.565 NA        NA     IF NWPL Rocky Mountains Basis  ## 16    19    20 numeric    -0.545 NA        NA     IF NWPL Rocky Mountains Basis  ## 17    20    19 numeric    -0.494 NA        NA     IF NWPL Rocky Mountains Basis  ## 18    20    20 numeric    -0.474 NA        NA     IF NWPL Rocky Mountains Basis  ## 19    21    19 numeric    -0.585 NA        NA     IF NWPL Rocky Mountains Basis  ## 20    21    20 numeric    -0.565 NA        NA     IF NWPL Rocky Mountains Basis  ## 21    22    19 numeric    -0.295 NA        NA     IF NWPL Rocky Mountains Basis  ## 22    22    20 numeric    -0.275 NA        NA     IF NWPL Rocky Mountains Basis  ## 23    23    19 numeric    -0.530 NA        NA     IF NWPL Rocky Mountains Basis  ## 24    23    20 numeric    -0.510 NA        NA     IF NWPL Rocky Mountains Basis  ## # ℹ 1 more variable: bid_offer <chr> unpivoted <-   purrr::map_dfr(partitions$cells,                  ~ .x %>%                    behead(\"NNW\", \"title\") %>%                    behead(\"NNW\", \"price\") %>%                    behead(\"N\", \"bid_offer\")) %>%   select(-data_type, -character, -date) unpivoted ## # A tibble: 240 × 6 ##      row   col numeric title                   price       bid_offer ##    <int> <int>   <dbl> <chr>                   <chr>       <chr>     ##  1    17    17    1.89 IF NWPL Rocky Mountains Fixed Price BID       ##  2    17    18    1.91 IF NWPL Rocky Mountains Fixed Price OFFER     ##  3    18    17    2.06 IF NWPL Rocky Mountains Fixed Price BID       ##  4    18    18    2.08 IF NWPL Rocky Mountains Fixed Price OFFER     ##  5    19    17    2.40 IF NWPL Rocky Mountains Fixed Price BID       ##  6    19    18    2.42 IF NWPL Rocky Mountains Fixed Price OFFER     ##  7    20    17    2.59 IF NWPL Rocky Mountains Fixed Price BID       ##  8    20    18    2.61 IF NWPL Rocky Mountains Fixed Price OFFER     ##  9    21    17    2.58 IF NWPL Rocky Mountains Fixed Price BID       ## 10    21    18    2.60 IF NWPL Rocky Mountains Fixed Price OFFER     ## # ℹ 230 more rows row_headers <-   cells %>%   dplyr::filter(between(row, 17, 56), between(col, 2, 4)) %>%   # Concatenate rows like \"Dec-01\", \"to\", \"Mar-02\"   mutate(character = ifelse(!is.na(character),                             character,                             format(date, origin=\"1899-12-30\", \"%b-%y\"))) %>%   select(row, col, character) %>%   nest(-row) %>%   mutate(row_header = map(data,                           ~ str_trim(paste(.x$character, collapse = \" \")))) %>%   unnest(row_header) %>%   mutate(col = 2L) %>%   select(row, row_header) ## Warning: Supplying `...` without names was deprecated in tidyr 1.0.0. ## ℹ Please specify a name for each selection. ## ℹ Did you want `data = -row`? ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. unpivoted <- left_join(unpivoted, row_headers, by = \"row\") unpivoted ## # A tibble: 240 × 7 ##      row   col numeric title                   price       bid_offer row_header  ##    <int> <int>   <dbl> <chr>                   <chr>       <chr>     <chr>       ##  1    17    17    1.89 IF NWPL Rocky Mountains Fixed Price BID       Cash        ##  2    17    18    1.91 IF NWPL Rocky Mountains Fixed Price OFFER     Cash        ##  3    18    17    2.06 IF NWPL Rocky Mountains Fixed Price BID       ROM         ##  4    18    18    2.08 IF NWPL Rocky Mountains Fixed Price OFFER     ROM         ##  5    19    17    2.40 IF NWPL Rocky Mountains Fixed Price BID       Dec-01      ##  6    19    18    2.42 IF NWPL Rocky Mountains Fixed Price OFFER     Dec-01      ##  7    20    17    2.59 IF NWPL Rocky Mountains Fixed Price BID       Dec-01 to … ##  8    20    18    2.61 IF NWPL Rocky Mountains Fixed Price OFFER     Dec-01 to … ##  9    21    17    2.58 IF NWPL Rocky Mountains Fixed Price BID       Apr-02 to … ## 10    21    18    2.60 IF NWPL Rocky Mountains Fixed Price OFFER     Apr-02 to … ## # ℹ 230 more rows"},{"path":"https://nacnudus.github.io/unpivotr/articles/small-multiples.html","id":"line-code-listing","dir":"Articles","previous_headings":"","what":"34-line code listing","title":"Small Multiples","text":"","code":"library(unpivotr) library(tidyxl) library(dplyr) library(purrr) library(tidyr) library(stringr)  cells <-   xlsx_cells(system.file(\"extdata/enron.xlsx\", package = \"unpivotr\")) %>%   dplyr::filter(!is_blank, between(row, 14L, 56L), col <= 20) %>%   select(row, col, data_type, numeric, character, date)  row_headers <-   dplyr::filter(cells, between(row, 17, 56), between(col, 2, 4)) %>%   mutate(character = ifelse(!is.na(character),                             character,                             format(date, origin=\"1899-12-30\", \"%b-%y\"))) %>%   select(row, col, character) %>%   nest(-row) %>%   mutate(row_header = map(data,                           ~ str_trim(paste(.x$character, collapse = \" \")))) %>%   unnest(row_header) %>%   mutate(col = 2L) %>%   select(row, row_header)  titles <-   dplyr::filter(cells, character == \"Fixed Price\") %>%   select(row, col) %>%   mutate(row = row - 1L) %>%   inner_join(cells, by = c(\"row\", \"col\"))  partition(cells, titles)$cells %>%   purrr::map_dfr(~ .x %>%                  behead(\"NNW\", \"title\") %>%                  behead(\"NNW\", \"price\") %>%                  behead(\"N\", \"bid_offer\")) %>%   select(-data_type, -character, -date) %>%   left_join(row_headers, by = \"row\")"},{"path":"https://nacnudus.github.io/unpivotr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Duncan Garmonsway. Author, maintainer.","code":""},{"path":"https://nacnudus.github.io/unpivotr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Garmonsway D (2025). unpivotr: Unpivot Complex Irregular Data Layouts. R package version 0.6.4, https://nacnudus.github.io/unpivotr/, https://github.com/nacnudus/unpivotr.","code":"@Manual{,   title = {unpivotr: Unpivot Complex and Irregular Data Layouts},   author = {Duncan Garmonsway},   year = {2025},   note = {R package version 0.6.4, https://nacnudus.github.io/unpivotr/},   url = {https://github.com/nacnudus/unpivotr}, }"},{"path":"https://nacnudus.github.io/unpivotr/index.html","id":"unpivotr","dir":"","previous_headings":"","what":"Unpivot Complex and Irregular Data Layouts","title":"Unpivot Complex and Irregular Data Layouts","text":"unpivotr deals non-tabular data, especially spreadsheets. Use unpivotr source data ‘features’: Multi-headered hydra Meaningful formatting Headers anywhere top column Non-text headers e.g. dates stuff around table Several similar tables one sheet Sentinel values Superscript symbols Meaningful comments Nested HTML tables list makes blood boil, ’ll enjoy function names. behead() deals multi-headered hydra tables one layer headers time, working edge table inwards. ’s bit like using header = TRUE read.csv(), ’s function, can apply many layers headers need. end headers columns. spatter() like tidyr::spread() preserves mixed data types. get mixed-data-type situation delaying type coercion table tidy (rather , like read.csv() et al). yes, usually follows behead(). positive, corrective functions: justify() aligns column headers behead()ing, deliberate moral overtones. enhead() attaches header body data, la Frankenstein. effect behead(), powerful can choose exactly header cells want, paying attention formatting (behead() doesn’t understand). isolate_sentinels() separates meaningful symbols like \"N/\" \"confidential\" rest data, giving time alone think ’ve done. partition() takes sheet several tables , slashes pieces contain one table. can unpivot table turn purrr::map() similar.","code":""},{"path":"https://nacnudus.github.io/unpivotr/index.html","id":"make-cells-tidy","dir":"","previous_headings":"","what":"Make cells tidy","title":"Unpivot Complex and Irregular Data Layouts","text":"Unpivotr uses data cells represented one row dataframe. Like . Gif tidyxl converting cells tidy representation one row per cell can tidy cells? best places start : Spreadsheet Munging Strategies, free, online cookbook using tidyxl unpivotr Screencasts YouTube. Worked examples GitHub. Otherwise basic idea : spreadsheets, use tidyxl. plain text files, might soon able use readr, now ’ll install pull-request package devtools::install_github(\"tidyverse/readr#760\"). tables html pages, use unpivotr::tidy_html() data frames, use unpivotr::as_cells() – last resort, time data conventional data frame, often late – formatting lost, data types coerced strings. Either behead() straight away, else dplyr::filter() separately header cells data cells, recombine enhead(). spatter() column one data type. Note compass directions code , hint behead() find header cell data cell. \"-left\" means header (Female, Male) positioned left columns data cells describes. \"\" means header (0 - 6, 7 - 10) positioned directly columns data cells describes. \"left-\" means header (Bachelor's degree, Certificate, etc.) positioned left upwards rows data cells describes. \"left\" means header (15 - 24, 25 - 44, etc.) positioned directly left rows data cells describes.","code":"library(unpivotr) library(tidyverse) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.5 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.5.1     ✔ tibble    3.2.1 #> ✔ lubridate 1.9.3     ✔ tidyr     1.3.1 #> ✔ purrr     1.0.2      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ✖ tidyr::pack()   masks unpivotr::pack() #> ✖ tidyr::unpack() masks unpivotr::unpack() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors x <- purpose$`up-left left-up` x # A pivot table in a conventional data frame.  Four levels of headers, in two #>                            X2      X3     X4     X5    X6     X7 #> 1                        <NA>    <NA> Female   <NA>  Male   <NA> #> 2                        <NA>    <NA>  0 - 6 7 - 10 0 - 6 7 - 10 #> 3           Bachelor's degree 15 - 24   7000  27000  <NA>  13000 #> 4                        <NA> 25 - 44  12000 137000  9000  81000 #> 5                        <NA> 45 - 64  10000  64000  7000  66000 #> 6                        <NA>     65+   <NA>  18000  7000  17000 #> 7                 Certificate 15 - 24  29000 161000 30000 190000 #> 8                        <NA> 25 - 44  34000 179000 31000 219000 #> 9                        <NA> 45 - 64  30000 210000 23000 199000 #> 10                       <NA>     65+  12000  77000  8000 107000 #> 11                    Diploma 15 - 24   <NA>  14000  9000  11000 #> 12                       <NA> 25 - 44  10000  66000  8000  47000 #> 13                       <NA> 45 - 64   6000  68000  5000  58000 #> 14                       <NA>     65+   5000  41000  1000  34000 #> 15           No Qualification 15 - 24  10000  43000 12000  37000 #> 16                       <NA> 25 - 44  11000  36000 21000  50000 #> 17                       <NA> 45 - 64  19000  91000 17000  75000 #> 18                       <NA>     65+  16000 118000  9000  66000 #> 19 Postgraduate qualification 15 - 24   <NA>   6000  <NA>   <NA> #> 20                       <NA> 25 - 44   5000  86000  7000  60000 #> 21                       <NA> 45 - 64   6000  55000  6000  68000 #> 22                       <NA>     65+   <NA>  13000  <NA>  18000   # rows and two columns.  y <- as_cells(x) # 'Tokenize' or 'melt' the data frame into one row per cell y #> # A tibble: 132 × 4 #>      row   col data_type chr               #>    <int> <int> <chr>     <chr>             #>  1     1     1 chr       <NA>              #>  2     2     1 chr       <NA>              #>  3     3     1 chr       Bachelor's degree #>  4     4     1 chr       <NA>              #>  5     5     1 chr       <NA>              #>  6     6     1 chr       <NA>              #>  7     7     1 chr       Certificate       #>  8     8     1 chr       <NA>              #>  9     9     1 chr       <NA>              #> 10    10     1 chr       <NA>              #> # ℹ 122 more rows  rectify(y) # useful for reviewing the melted form as though in a spreadsheet #> # A tibble: 22 × 7 #>    `row/col` `1(A)`            `2(B)`  `3(C)` `4(D)` `5(E)` `6(F)` #>        <int> <chr>             <chr>   <chr>  <chr>  <chr>  <chr>  #>  1         1 <NA>              <NA>    Female <NA>   Male   <NA>   #>  2         2 <NA>              <NA>    0 - 6  7 - 10 0 - 6  7 - 10 #>  3         3 Bachelor's degree 15 - 24 7000   27000  <NA>   13000  #>  4         4 <NA>              25 - 44 12000  137000 9000   81000  #>  5         5 <NA>              45 - 64 10000  64000  7000   66000  #>  6         6 <NA>              65+     <NA>   18000  7000   17000  #>  7         7 Certificate       15 - 24 29000  161000 30000  190000 #>  8         8 <NA>              25 - 44 34000  179000 31000  219000 #>  9         9 <NA>              45 - 64 30000  210000 23000  199000 #> 10        10 <NA>              65+     12000  77000  8000   107000 #> # ℹ 12 more rows  y %>%   behead(\"up-left\", \"sex\") %>%               # Strip headers   behead(\"up\", \"life-satisfication\") %>%  # one   behead(\"left-up\", \"qualification\") %>%     # by   behead(\"left\", \"age-band\") %>%            # one.   select(-row, -col, -data_type, count = chr) %>% # cleanup   mutate(count = as.integer(count)) #> # A tibble: 80 × 5 #>     count sex    `life-satisfication` qualification     `age-band` #>     <int> <chr>  <chr>                <chr>             <chr>      #>  1   7000 Female 0 - 6                Bachelor's degree 15 - 24    #>  2  12000 Female 0 - 6                Bachelor's degree 25 - 44    #>  3  10000 Female 0 - 6                Bachelor's degree 45 - 64    #>  4     NA Female 0 - 6                Bachelor's degree 65+        #>  5  27000 Female 7 - 10               Bachelor's degree 15 - 24    #>  6 137000 Female 7 - 10               Bachelor's degree 25 - 44    #>  7  64000 Female 7 - 10               Bachelor's degree 45 - 64    #>  8  18000 Female 7 - 10               Bachelor's degree 65+        #>  9     NA Male   0 - 6                Bachelor's degree 15 - 24    #> 10   9000 Male   0 - 6                Bachelor's degree 25 - 44    #> # ℹ 70 more rows"},{"path":"https://nacnudus.github.io/unpivotr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Unpivot Complex and Irregular Data Layouts","text":"version 0.4.0 release somee breaking changes. See NEWS.md details. previous version can installed follow:","code":"# install.packages(\"devtools\") # If you don't already have devtools devtools::install_github(\"nacnudus/unpivotr\", build_vignettes = TRUE) devtools::install_version(\"unpivotr\", version = \"0.3.1\", repos = \"http://cran.us.r-project.org\")"},{"path":"https://nacnudus.github.io/unpivotr/index.html","id":"similar-projects","dir":"","previous_headings":"","what":"Similar projects","title":"Unpivot Complex and Irregular Data Layouts","text":"unpivotr inspired Databaker, collaboration United Kingdom Office National Statistics Sensible Code Company. unpivotr. jailbreaker attempts extract non-tabular data spreadsheets tabular structures automatically via clever algorithms. unpivotr differs less magic, equipping express want .","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Tokenize data frames into a tidy 'melted' structure — as_cells","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"Data frames represent data tabular structure.  as_cells() takes row column position 'cell', returns information new data frame, alongside content type cell. makes easier deal complex non-tabular data (e.g. pivot tables) imported R data frames.  'melted' as_cells(), can use functions like behead() spatter() reshape conventional, tidy, unpivoted structures. HTML tables, content cell returned standalone HTML string can parsed tools rvest package.  particularly useful HTML cell contains HTML table, contains text URL.  HTML poorly formatted, try passing htmltidy package first. S3 generic.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"","code":"as_cells(x, row_names = FALSE, col_names = FALSE)"},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"x data.frame HTML document row_names Whether treat row names cells, Default: FALSE col_names Whether treat column names  cells, Default: FALSE","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"data.frame following columns: row col (integer) giving original position 'cells' relevant columns cell values original types: chr, cplx, cplx, dbl, fct, int, lgl, list, ord data_type specify cell columns (chr etc.) value . columns fct ord , like list, list-columns (element independent) avoid factor levels clashing.  HTML tables, column html gives HTML string original cell. Row column names, present required row_names = TRUE col_names = TRUE, treated though cells table, appear chr column.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"certain non-rectangular data formats, can useful parse data melted format row represents single token.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/as_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tokenize data frames into a tidy 'melted' structure — as_cells","text":"","code":"x <- data.frame(a = c(10, 20),                 b = c(\"foo\", \"bar\"),                 stringsAsFactors = FALSE) x #>    a   b #> 1 10 foo #> 2 20 bar as_cells(x) #> # A tibble: 4 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 dbl       NA       10 #> 2     2     1 dbl       NA       20 #> 3     1     2 chr       foo      NA #> 4     2     2 chr       bar      NA as_cells(x, row_names = TRUE) #> # A tibble: 6 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 chr       1        NA #> 2     2     1 chr       2        NA #> 3     1     2 dbl       NA       10 #> 4     2     2 dbl       NA       20 #> 5     1     3 chr       foo      NA #> 6     2     3 chr       bar      NA as_cells(x, col_names = TRUE) #> # A tibble: 6 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 chr       a        NA #> 2     2     1 dbl       NA       10 #> 3     3     1 dbl       NA       20 #> 4     1     2 chr       b        NA #> 5     2     2 chr       foo      NA #> 6     3     2 chr       bar      NA  # 'list' columns are undisturbed y <- data.frame(a = c(\"a\", \"b\"), stringsAsFactors = FALSE) y$b <- list(1:2, 3:4) y #>   a    b #> 1 a 1, 2 #> 2 b 3, 4 as_cells(y) #> # A tibble: 4 × 5 #>     row   col data_type chr   list      #>   <int> <int> <chr>     <chr> <list>    #> 1     1     1 chr       a     <NULL>    #> 2     2     1 chr       b     <NULL>    #> 3     1     2 list      NA    <int [2]> #> 4     2     2 list      NA    <int [2]>  # Factors are preserved by being wrapped in lists so that their levels don't # conflict.  Blanks are NULLs. z <- data.frame(x = factor(c(\"a\", \"b\")),                 y = factor(c(\"c\", \"d\"), ordered = TRUE)) as_cells(z) #> # A tibble: 4 × 5 #>     row   col data_type fct       ord       #>   <int> <int> <chr>     <list>    <list>    #> 1     1     1 fct       <fct [1]> <NULL>    #> 2     2     1 fct       <fct [1]> <NULL>    #> 3     1     2 ord       <NULL>    <ord [1]> #> 4     2     2 ord       <NULL>    <ord [1]> as_cells(z)$fct #> [[1]] #> [1] a #> Levels: a b #>  #> [[2]] #> [1] b #> Levels: a b #>  #> [[3]] #> NULL #>  #> [[4]] #> NULL #>  as_cells(z)$ord #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] c #> Levels: c < d #>  #> [[4]] #> [1] d #> Levels: c < d #>   # HTML tables can be extracted from the output of xml2::read_html().  These # are returned as a list of tables, similar to rvest::html_table().  The # value of each cell is its standalone HTML string, which can contain # anything -- even another table.  colspan <- system.file(\"extdata\", \"colspan.html\", package = \"unpivotr\") rowspan <- system.file(\"extdata\", \"rowspan.html\", package = \"unpivotr\") nested <- system.file(\"extdata\", \"nested.html\", package = \"unpivotr\")  if (FALSE) { # \\dontrun{ browseURL(colspan) browseURL(rowspan) browseURL(nestedspan) } # }  as_cells(xml2::read_html(colspan)) #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                     #>   <int> <int> <chr>     <chr>                                    #> 1     1     1 html      \"<th colspan=\\\"2\\\">Header (1, 1:2)<\/th>\" #> 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                   #> 3     1     2 html       NA                                      #> 4     2     2 html      \"<td>cell (2, 2)<\/td>\"                   #>  as_cells(xml2::read_html(rowspan)) #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                     #>   <int> <int> <chr>     <chr>                                    #> 1     1     1 html      \"<th rowspan=\\\"2\\\">Header (1:2, 1)<\/th>\" #> 2     2     1 html       NA                                      #> 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                 #> 4     2     2 html      \"<td>cell (2, 2)<\/td>\"                   #>  as_cells(xml2::read_html(nested)) #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                                     #>   <int> <int> <chr>     <chr>                                                    #> 1     1     1 html      \"<th>Header (1, 1)<\/th>\"                                 #> 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                                   #> 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                                 #> 4     2     2 html      \"<td>\\n          <table>\\n<tr>\\n<th>Header (2, 2)(1, 1)… #>"},{"path":"https://nacnudus.github.io/unpivotr/reference/behead.html","id":null,"dir":"Reference","previous_headings":"","what":"Strip a level of headers from a pivot table — behead","title":"Strip a level of headers from a pivot table — behead","text":"behead() takes one level headers pivot table makes part data.  Think like tidyr::gather(), except works one row headers (one column row-headers), works tables first come as_cells() tidyxl::xlsx_cells().","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/behead.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Strip a level of headers from a pivot table — behead","text":"","code":"behead(   cells,   direction,   name,   values = NULL,   types = data_type,   formatters = list(),   drop_na = TRUE )  behead_if(   cells,   ...,   direction,   name,   values = NULL,   types = data_type,   formatters = list(),   drop_na = TRUE )"},{"path":"https://nacnudus.github.io/unpivotr/reference/behead.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Strip a level of headers from a pivot table — behead","text":"cells Data frame. cells pivot table, usually output as_cells() tidyxl::xlsx_cells(), subsequent operation outputs. direction direction data cell header, one \"\", \"right\", \"\", \"left\", \"-left\", \"-right\", \"right-\", \"right-\", \"-right\", \"-left\", \"left-\", \"left-\".  See ?direction.  \"-ish\", \"-ish\", \"left-ish\" \"right-ish\" available require certain ambiguities better handled using enhead() directly rather via behead(). name name give new column created, e.g. \"location\" headers locations.  Quoted (\"location\", location) refer actual object. values Optional. column cells use values header.  Given bare variable name.  omitted (default), types argument used instead. types name column names data type cell. Usually called data_types (default), character column names columns cells contain values cell. E.g.  cell character value \"character\" column. Unquoted(data_types, \"data_types\") refers actual object. formatters named list functions formatting data type set headers mixed data types, e.g. headers dates others characters.  can given character = toupper character = ~ toupper(.x), similar purrr::map. drop_na logical Whether filter headers NA value column.  Default: TRUE.  can happen output tidyxl::xlsx_cells(), empty cell exists formatting applied , ignored. ... Passed dplyr::filter. logical predicates defined terms variables .data.  Multiple conditions combined &. rows condition evaluates TRUE kept. arguments ... automatically quoted evaluated context data frame. support unquoting splicing. See dplyr vignette(\"programming\") introduction concepts.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/behead.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Strip a level of headers from a pivot table — behead","text":"data frame","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/behead.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Strip a level of headers from a pivot table — behead","text":"","code":"# A simple table with a row of headers (x <- data.frame(a = 1:2, b = 3:4)) #>   a b #> 1 1 3 #> 2 2 4  # Make a tidy representation of each cell (cells <- as_cells(x, col_names = TRUE)) #> # A tibble: 6 × 5 #>     row   col data_type chr     int #>   <int> <int> <chr>     <chr> <int> #> 1     1     1 chr       a        NA #> 2     2     1 int       NA        1 #> 3     3     1 int       NA        2 #> 4     1     2 chr       b        NA #> 5     2     2 int       NA        3 #> 6     3     2 int       NA        4  # Strip the cells in row 1 (the original headers) and use them as data behead(cells, \"N\", foo) #> # A tibble: 4 × 6 #>     row   col data_type chr     int foo   #>   <int> <int> <chr>     <chr> <int> <chr> #> 1     2     1 int       NA        1 a     #> 2     3     1 int       NA        2 a     #> 3     2     2 int       NA        3 b     #> 4     3     2 int       NA        4 b      # More complex example: pivot table with several layers of headers (x <- purpose$`up-left left-up`) #>                            X2      X3     X4     X5    X6     X7 #> 1                        <NA>    <NA> Female   <NA>  Male   <NA> #> 2                        <NA>    <NA>  0 - 6 7 - 10 0 - 6 7 - 10 #> 3           Bachelor's degree 15 - 24   7000  27000  <NA>  13000 #> 4                        <NA> 25 - 44  12000 137000  9000  81000 #> 5                        <NA> 45 - 64  10000  64000  7000  66000 #> 6                        <NA>     65+   <NA>  18000  7000  17000 #> 7                 Certificate 15 - 24  29000 161000 30000 190000 #> 8                        <NA> 25 - 44  34000 179000 31000 219000 #> 9                        <NA> 45 - 64  30000 210000 23000 199000 #> 10                       <NA>     65+  12000  77000  8000 107000 #> 11                    Diploma 15 - 24   <NA>  14000  9000  11000 #> 12                       <NA> 25 - 44  10000  66000  8000  47000 #> 13                       <NA> 45 - 64   6000  68000  5000  58000 #> 14                       <NA>     65+   5000  41000  1000  34000 #> 15           No Qualification 15 - 24  10000  43000 12000  37000 #> 16                       <NA> 25 - 44  11000  36000 21000  50000 #> 17                       <NA> 45 - 64  19000  91000 17000  75000 #> 18                       <NA>     65+  16000 118000  9000  66000 #> 19 Postgraduate qualification 15 - 24   <NA>   6000  <NA>   <NA> #> 20                       <NA> 25 - 44   5000  86000  7000  60000 #> 21                       <NA> 45 - 64   6000  55000  6000  68000 #> 22                       <NA>     65+   <NA>  13000  <NA>  18000  # Make a tidy representation cells <- as_cells(x) head(cells) #> # A tibble: 6 × 4 #>     row   col data_type chr               #>   <int> <int> <chr>     <chr>             #> 1     1     1 chr       NA                #> 2     2     1 chr       NA                #> 3     3     1 chr       Bachelor's degree #> 4     4     1 chr       NA                #> 5     5     1 chr       NA                #> 6     6     1 chr       NA                tail(cells) #> # A tibble: 6 × 4 #>     row   col data_type chr   #>   <int> <int> <chr>     <chr> #> 1    17     6 chr       75000 #> 2    18     6 chr       66000 #> 3    19     6 chr       NA    #> 4    20     6 chr       60000 #> 5    21     6 chr       68000 #> 6    22     6 chr       18000  # Strip the headers and make them into data tidy <-   cells %>%   behead(\"up-left\", Sex) %>%   behead(\"up\", `Sense of purpose`) %>%   behead(\"left-up\", `Highest qualification`) %>%   behead(\"left\", `Age group (Life-stages)`) %>%   dplyr::mutate(count = as.integer(chr)) %>%   dplyr::select(-row, -col, -data_type, -chr) head(tidy) #> # A tibble: 6 × 5 #>   Sex    `Sense of purpose` Highest qualificatio…¹ Age group (Life-stag…²  count #>   <chr>  <chr>              <chr>                  <chr>                   <int> #> 1 Female 0 - 6              Bachelor's degree      15 - 24                  7000 #> 2 Female 0 - 6              Bachelor's degree      25 - 44                 12000 #> 3 Female 0 - 6              Bachelor's degree      45 - 64                 10000 #> 4 Female 0 - 6              Bachelor's degree      65+                        NA #> 5 Female 7 - 10             Bachelor's degree      15 - 24                 27000 #> 6 Female 7 - 10             Bachelor's degree      25 - 44                137000 #> # ℹ abbreviated names: ¹​`Highest qualification`, ²​`Age group (Life-stages)`  # Check against the provided 'tidy' version of the data. dplyr::anti_join(tidy, purpose$Tidy) #> Joining with `by = join_by(Sex, `Sense of purpose`, `Highest qualification`, #> `Age group (Life-stages)`)` #> # A tibble: 1 × 5 #>   Sex   `Sense of purpose` `Highest qualification`  Age group (Life-stag…¹ count #>   <chr> <chr>              <chr>                    <chr>                  <int> #> 1 Male  0 - 6              Postgraduate qualificat… 15 - 24                   NA #> # ℹ abbreviated name: ¹​`Age group (Life-stages)`  # The provided 'tidy' data is missing a row for Male 15-24-year-olds with a # postgraduate qualification and a sense of purpose between 0 and 6.  That # seems to have been an oversight by Statistics New Zealand.  cells <- tibble::tribble(        ~X1, ~adult, ~juvenile,     \"LION\",    855,       677,     \"male\",    496,       322,   \"female\",    359,       355,    \"TIGER\",    690,       324,     \"male\",    381,       222,   \"female\",    309,       102   ) cells <- as_cells(cells, col_names = TRUE)  cells %>%   behead_if(chr == toupper(chr), direction = \"left-up\", name = \"species\") %>%   behead(\"left\", \"sex\") %>%   behead(\"up\", \"age\") %>%   dplyr::select(species, sex, age, population = dbl) #> # A tibble: 12 × 4 #>    species sex    age      population #>    <chr>   <chr>  <chr>         <dbl> #>  1 LION    NA     adult           855 #>  2 LION    male   adult           496 #>  3 LION    female adult           359 #>  4 LION    NA     juvenile        677 #>  5 LION    male   juvenile        322 #>  6 LION    female juvenile        355 #>  7 TIGER   NA     adult           690 #>  8 TIGER   male   adult           381 #>  9 TIGER   female adult           309 #> 10 TIGER   NA     juvenile        324 #> 11 TIGER   male   juvenile        222 #> 12 TIGER   female juvenile        102"},{"path":"https://nacnudus.github.io/unpivotr/reference/direction.html","id":null,"dir":"Reference","previous_headings":"","what":"Directions from data cells to headers — direction","title":"Directions from data cells to headers — direction","text":"use functions direction parameter. Data cells relate header cells proximity given direction. point view always data cell header.  example, direction \"\" means \"data cell go directly cell edge table, header cell.\" Scroll \"Tables\" section visual explanation. Legacy directions \"N\", \"NNW\", \"W\", \"WNW\"`, etc. still supported. Scroll \"Legacy directions\" section map new directions. \"\" means data cell go directly cell edge table, header cell. \"-left\" means data cell go directly cell edge table, cell blank go left cell value, header cell. \"-right\" means data cell go directly cell edge table, cell blank go right cell value, header cell. \"left\" means data cell go directly left cell edge table, header cell. \"left-\" means data cell go directly left cell edge table, cell blank go cell value, header cell. \"left-\" means data cell go directly left cell edge table, cell blank go cell value, header cell. \"right\" means data cell go directly right cell edge table, header cell. \"right-\" means data cell go directly right cell edge table, cell blank go cell value, header cell. \"right-\" means data cell go directly right cell edge table, cell blank go cell value, header cell. \"\" means data cell go directly cell edge table, header cell. \"-left\" means data cell go directly cell edge table, cell blank go left cell value, header cell. \"-right\" means data cell go directly cell edge table, cell blank go right cell value, header cell.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/direction.html","id":"-ish","dir":"Reference","previous_headings":"","what":"-ish","title":"Directions from data cells to headers — direction","text":"difference \"\" \"-ish\" (similar pairs directions) \"\" finds headers directly data cell, whereas \"-ish\" matches nearest header, whether -left, -right directly data cell.  useful matching headers aligned edge data cells refer .  can tie directions \"-ish\", \"-ish\", \"left-ish\" \"right-ish\" , causing NAs returned place header values.  Avoid ties using justify() first align header cells corner data cells describe. \"-ish\" means closest cell top edge table without crossing border defined border parameter. \"left-ish\" means closest cell left-hand edge table without crossing border defined border parameter. \"right-ish\" means closest cell right-hand edge table without crossing border defined border parameter. \"-ish\" means closest cell bottom edge table without crossing border defined border parameter.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/direction.html","id":"tables","dir":"Reference","previous_headings":"","what":"Tables","title":"Directions from data cells to headers — direction","text":"","code":"+----------------+-------------+-------------+ |                | up-left     | up-left     | +                +-------------+-------------+ |                | up   | up   | up   | up   | +----------------+------+------+------+------+ | left-up | left | data | data | data | data | +         +------+------+------+------+------+ |         | left | data | data | data | data | +---------+------+------+------+------+------+ | left-up | left | data | data | data | data | +         +------+------+------+------+------+ |         | left | data | data | data | data | +---------+------+------+------+------+------+ +-------------+-------------+------------------+ | up-right    | up-right    |                  | +-------------+-------------+                  + | up   | up   | up   | up   |                  | +------+------+------+------+------------------+ | data | data | data | data | right | right-up | +------+------+------+------+-------+          + | data | data | data | data | right |          | +------+------+------+------+-------+----------+ | data | data | data | data | right | right-up | +------+------+------+------+-------+          + | data | data | data | data | right |          | +------+------+------+------+-------+----------+ +-----------+------+------+------+------+------+ |           | left | data | data | data | data | +           +------+------+------+------+------+ | left-down | left | data | data | data | data | +-----------+------+------+------+------+------+ |           | left | data | data | data | data | +           +------+------+------+------+------+ | left-down | left | data | data | data | data | +-----------+------+------+------+------+------+ |                  | down | down | down | down | +                  +------+------+------+------+ |                  | down-left   | down-left   | +-----------+------+-------------+-------------+ '+------+------+------+------+-------+------------+ | data | data | data | data | right |            | +------+------+------+------+-------+            + | data | data | data | data | right | right-down | +------+------+------+------+-------+------------+ | data | data | data | data | right |            | +------+------+------+------+-------+            + | data | data | data | data | right | right-down | +------+------+------+------+-------+------------+ | down | down | down | down |                    | +------+------+------+------+                    + |  down-right |  down-right |                    | +-------------+-------------+--------------------+ +-----------------+----------------------+-----------------------------+ |                 |        up-ish        |               up-ish        | +                 +----------------------+-----------------------------+ |                 | up   | up     | up   | up   | up   | up     | up   | +-----------------+------+--------+------+------+------+--------+------+ |          | left | data | data   | data | data | data | data   | data | +          +------+------+--------+------+------+------+--------+------+ | left-ish | left | data | data   | data | data | data | data   | data | +          +------+------+--------+------+------+------+--------+------+ |          | left | data | data   | data | data | data | data   | data | +----------+------+------+--------+------+------+------+--------+------+ |          | left | data | data   | data | data | data | data   | data | +          +------+------+--------+------+------+------+--------+------+ |          | left | data | data   | data | data | data | data   | data | +          +------+------+--------+------+------+------+--------+------+ | left-ish | left | data | data   | data | data | data | data   | data | +          +------+------+--------+------+------+------+--------+------+ |          | left | data | data   | data | data | data | data   | data | +----------+------+------+--------+------+------+------+-----  -+------+ +------+----------+------+------+------+----------+------+-------+-----------+ | data | data     | data | data | data | data     | data | right |           | +------+----------+------+------+------+----------+------+-------+           + | data | data     | data | data | data | data     | data | right | right-ish | +------+----------+------+------+------+----------+------+-------+           + | data | data     | data | data | data | data     | data | right |           | +------+----------+------+------+------+----------+------+-------+-----------+ | data | data     | data | data | data | data     | data | right |           | +------+----------+------+------+------+----------+------+-------+           + | data | data     | data | data | data | data     | data | right |           | +------+----------+------+------+------+----------+------+-------+           + | data | data     | data | data | data | data     | data | right | right-ish | +------+----------+------+------+------+----------+------+-------+           + | data | data     | data | data | data | data     | data | right |           | +------+----------+------+------+------+----------+------+-------+-----------+ | down | down     | down | down | down | down     | down |                   | +------+----------+------+------+------+----------+------+                   + |        down-ish        |               down-ish        |                   | +------------------------+-------------------------------+-------------------+"},{"path":"https://nacnudus.github.io/unpivotr/reference/direction.html","id":"legacy-directions","dir":"Reference","previous_headings":"","what":"Legacy directions","title":"Directions from data cells to headers — direction","text":"Older versions unpivotr used different names directions, based points compass.  still supported discouraged.","code":"| old direction | new direction | |---------------|---------------| | N             | up            | | NNW           | up-left       | | NNE           | up-right      | | W             | left          | | WNW           | left-up       | | WSW           | left-down     | | E             | right         | | ENE           | right-up      | | ESE           | right-down    | | S             | down          | | SSW           | down-left     | | SSE           | down-right    |"},{"path":"https://nacnudus.github.io/unpivotr/reference/enhead.html","id":null,"dir":"Reference","previous_headings":"","what":"Join data cells to headers — enhead","title":"Join data cells to headers — enhead","text":"Data cells table associated header cells proximity. enhead() joins data frame data cells data frame header cells, choosing nearest header cells given direction.  See ?direction.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/enhead.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join data cells to headers — enhead","text":"","code":"enhead(data_cells, header_cells, direction, drop = TRUE)"},{"path":"https://nacnudus.github.io/unpivotr/reference/enhead.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join data cells to headers — enhead","text":"data_cells Data frame data cells least columns 'row' 'column', numeric integer. header_cells Data frame header cells least columns 'row' 'column', numeric/integer vectors. direction direction data cell header, one \"\", \"right\", \"\", \"left\", \"-left\", \"-right\", \"right-\", \"right-\", \"-right\", \"-left\", \"left-\", \"left-\", \"-ish\", \"-ish\", \"left-ish\" \"right-ish\". See ?direction. drop Logical vector length 1. Whether data cells associated header dropped.  Default: TRUE.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/enhead.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join data cells to headers — enhead","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union # Load some pivoted data (x <- purpose$`up-left left-up`) #>                            X2      X3     X4     X5    X6     X7 #> 1                        <NA>    <NA> Female   <NA>  Male   <NA> #> 2                        <NA>    <NA>  0 - 6 7 - 10 0 - 6 7 - 10 #> 3           Bachelor's degree 15 - 24   7000  27000  <NA>  13000 #> 4                        <NA> 25 - 44  12000 137000  9000  81000 #> 5                        <NA> 45 - 64  10000  64000  7000  66000 #> 6                        <NA>     65+   <NA>  18000  7000  17000 #> 7                 Certificate 15 - 24  29000 161000 30000 190000 #> 8                        <NA> 25 - 44  34000 179000 31000 219000 #> 9                        <NA> 45 - 64  30000 210000 23000 199000 #> 10                       <NA>     65+  12000  77000  8000 107000 #> 11                    Diploma 15 - 24   <NA>  14000  9000  11000 #> 12                       <NA> 25 - 44  10000  66000  8000  47000 #> 13                       <NA> 45 - 64   6000  68000  5000  58000 #> 14                       <NA>     65+   5000  41000  1000  34000 #> 15           No Qualification 15 - 24  10000  43000 12000  37000 #> 16                       <NA> 25 - 44  11000  36000 21000  50000 #> 17                       <NA> 45 - 64  19000  91000 17000  75000 #> 18                       <NA>     65+  16000 118000  9000  66000 #> 19 Postgraduate qualification 15 - 24   <NA>   6000  <NA>   <NA> #> 20                       <NA> 25 - 44   5000  86000  7000  60000 #> 21                       <NA> 45 - 64   6000  55000  6000  68000 #> 22                       <NA>     65+   <NA>  13000  <NA>  18000 # Make a tidy representation cells <- as_cells(x) cells <- cells[!is.na(cells$chr), ] head(cells) #> # A tibble: 6 × 4 #>     row   col data_type chr                        #>   <int> <int> <chr>     <chr>                      #> 1     3     1 chr       Bachelor's degree          #> 2     7     1 chr       Certificate                #> 3    11     1 chr       Diploma                    #> 4    15     1 chr       No Qualification           #> 5    19     1 chr       Postgraduate qualification #> 6     3     2 chr       15 - 24                    # Select the cells containing the values data_cells <-   filter(cells, row >= 3, col >= 3) %>%   transmute(row, col, count = as.integer(chr)) head(data_cells) #> # A tibble: 6 × 3 #>     row   col count #>   <int> <int> <int> #> 1     3     3  7000 #> 2     4     3 12000 #> 3     5     3 10000 #> 4     7     3 29000 #> 5     8     3 34000 #> 6     9     3 30000 # Select the headers qualification <-   filter(cells, col == 1) %>%   select(row, col, qualification = chr) age <-   filter(cells, col == 2) %>%   select(row, col, age = chr) gender <-   filter(cells, row == 1) %>%   select(row, col, gender = chr) satisfaction <-   filter(cells, row == 2) %>%   select(row, col, satisfaction = chr) # From each data cell, search for the nearest one of each of the headers data_cells %>%   enhead(gender, \"up-left\") %>%   enhead(satisfaction, \"up\") %>%   enhead(qualification, \"left-up\") %>%   enhead(age, \"left\") %>%   select(-row, -col) #> # A tibble: 72 × 5 #>     count gender satisfaction qualification     age     #>     <int> <chr>  <chr>        <chr>             <chr>   #>  1   7000 Female 0 - 6        Bachelor's degree 15 - 24 #>  2  12000 Female 0 - 6        Bachelor's degree 25 - 44 #>  3  10000 Female 0 - 6        Bachelor's degree 45 - 64 #>  4  27000 Female 7 - 10       Bachelor's degree 15 - 24 #>  5 137000 Female 7 - 10       Bachelor's degree 25 - 44 #>  6  64000 Female 7 - 10       Bachelor's degree 45 - 64 #>  7  18000 Female 7 - 10       Bachelor's degree 65+     #>  8   9000 Male   0 - 6        Bachelor's degree 25 - 44 #>  9   7000 Male   0 - 6        Bachelor's degree 45 - 64 #> 10   7000 Male   0 - 6        Bachelor's degree 65+     #> # ℹ 62 more rows  # The `drop` argument controls what happens when for some cells there is no # header in the given direction. When `drop = TRUE` (the default), cells that # can't be joined to a header are dropped.  Otherwise they are kept. enhead(data_cells, gender, \"up\") #> # A tibble: 33 × 4 #>      row   col count gender #>    <int> <int> <int> <chr>  #>  1     3     3  7000 Female #>  2     4     3 12000 Female #>  3     5     3 10000 Female #>  4     7     3 29000 Female #>  5     8     3 34000 Female #>  6     9     3 30000 Female #>  7    10     3 12000 Female #>  8    12     3 10000 Female #>  9    13     3  6000 Female #> 10    14     3  5000 Female #> # ℹ 23 more rows enhead(data_cells, gender, \"up\", drop = FALSE) #> # A tibble: 72 × 4 #>      row   col count gender #>    <int> <int> <int> <chr>  #>  1     3     3  7000 Female #>  2     4     3 12000 Female #>  3     5     3 10000 Female #>  4     7     3 29000 Female #>  5     8     3 34000 Female #>  6     9     3 30000 Female #>  7    10     3 12000 Female #>  8    12     3 10000 Female #>  9    13     3  6000 Female #> 10    14     3  5000 Female #> # ℹ 62 more rows"},{"path":"https://nacnudus.github.io/unpivotr/reference/isolate_sentinels.html","id":null,"dir":"Reference","previous_headings":"","what":"Move sentinel values into a separate column leaving NA behind — isolate_sentinels","title":"Move sentinel values into a separate column leaving NA behind — isolate_sentinels","text":"sentinel value, takes place value available reason.  isolate_sentinels() removes values column data separate column, optionally converts data left behind appropriate data type.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/isolate_sentinels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Move sentinel values into a separate column leaving NA behind — isolate_sentinels","text":"","code":"isolate_sentinels(.data, col, sentinels, into = \"sentinel\")"},{"path":"https://nacnudus.github.io/unpivotr/reference/isolate_sentinels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Move sentinel values into a separate column leaving NA behind — isolate_sentinels","text":".data data frame. col name column data containing sentinel values. sentinels vector sentinel values removed. name give new column sentinel values.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/isolate_sentinels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Move sentinel values into a separate column leaving NA behind — isolate_sentinels","text":"","code":"x <- data.frame(name = c(\"Matilda\", \"Nicholas\", \"Olivia\", \"Paul\"),                 score = c(10, \"confidential\", \"N/A\", 12),                 stringsAsFactors = FALSE) x #>       name        score #> 1  Matilda           10 #> 2 Nicholas confidential #> 3   Olivia          N/A #> 4     Paul           12 isolate_sentinels(x, score, c(\"confidential\", \"N/A\")) #>       name score     sentinel #> 1  Matilda    10         <NA> #> 2 Nicholas  <NA> confidential #> 3   Olivia  <NA>          N/A #> 4     Paul    12         <NA> isolate_sentinels(x, score, c(\"confidential\", \"N/A\"), \"flag\") #>       name score         flag #> 1  Matilda    10         <NA> #> 2 Nicholas  <NA> confidential #> 3   Olivia  <NA>          N/A #> 4     Paul    12         <NA>"},{"path":"https://nacnudus.github.io/unpivotr/reference/justify.html","id":null,"dir":"Reference","previous_headings":"","what":"Align one set of cells with another set — justify","title":"Align one set of cells with another set — justify","text":"header cells table aligned left, right, top bottom data cells describe, use justify() re-align , using second set cells guide.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/justify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align one set of cells with another set — justify","text":"","code":"justify(header_cells, corner_cells)"},{"path":"https://nacnudus.github.io/unpivotr/reference/justify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align one set of cells with another set — justify","text":"header_cells Data frame data cells least columns 'row' 'column', numeric integer. corner_cells Data frame header cells least columns 'row' 'column', numeric/integer vectors.  length header_cells.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/justify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align one set of cells with another set — justify","text":"","code":"header_cells <- tibble::tibble(row = c(1L, 1L, 1L, 1L),                                col = c(3L, 5L, 8L, 10L),                                value = LETTERS[1:4]) corner_cells <- tibble::tibble(row = c(2L, 2L, 2L, 2L),                                col = c(1L, 4L, 6L, 9L)) justify(header_cells, corner_cells) #> # A tibble: 4 × 3 #>     row   col value #>   <int> <int> <chr> #> 1     2     1 A     #> 2     2     4 B     #> 3     2     6 C     #> 4     2     9 D"},{"path":"https://nacnudus.github.io/unpivotr/reference/merge_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge cell values into a single cell by rows or columns — merge_cells","title":"Merge cell values into a single cell by rows or columns — merge_cells","text":"single column header split across cells, merge cells merge_rows() merge_cols().  E.g. column header \"Mean GDP\" split two cells, top cell value \"Mean\" bottom cell value \"GDP\", merge_rows() combine single cell value \"Mean GDP\". merge_rows() keeps top cell, merge_cols() keeps left-cell.  several columns headers, merge_rows() aligns output cells row, similarly merge_cols() aligns column. functions apply cells character values make sense concatenate non-character values.  Convert cell values characters first need merge non-character cells. Columns one concatenated take value top left-cell.  example, cells columns data_type is_blank, top left-cell values blank TRUE columns, resulting merged cell also values blank TRUE columns, even concatenated value longer blank.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/merge_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge cell values into a single cell by rows or columns — merge_cells","text":"","code":"merge_rows(cells, rows, values, collapse = \" \")  merge_cols(cells, cols, values, collapse = \" \")"},{"path":"https://nacnudus.github.io/unpivotr/reference/merge_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge cell values into a single cell by rows or columns — merge_cells","text":"cells Data frame. cells pivot table, usually output as_cells() tidyxl::xlsx_cells(), subsequent operation outputs. rows numbers rows merged. values column cells use values cell merged.  Given bare variable name. collapse character string separate values cell. cols numbers columns merged.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/merge_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge cell values into a single cell by rows or columns — merge_cells","text":"data frame","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/merge_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge cell values into a single cell by rows or columns — merge_cells","text":"","code":"x <- tibble::tribble( ~row, ~col, ~data_type,     ~chr,    1,    1,      \"chr\",   \"Katy\",    2,    1,      \"chr\",  \"Perry\",    3,    1,      \"chr\",      \"a\",    4,    1,      \"chr\",      \"b\",    5,    1,      \"chr\",      \"c\",    2,    2,      \"chr\",  \"Adele\",    3,    2,      \"chr\",      \"d\",    4,    2,      \"chr\",      \"e\",    5,    2,      \"chr\",      \"f\",    1,    3,      \"chr\", \"Ariana\",    2,    3,      \"chr\", \"Grande\",    3,    3,      \"chr\",      \"g\",    4,    3,      \"chr\",      \"h\",    5,    3,      \"chr\",      \"i\" ) rectify(x) #> # A tibble: 5 × 4 #>   `row/col` `1(A)` `2(B)` `3(C)` #>       <dbl> <chr>  <chr>  <chr>  #> 1         1 Katy   NA     Ariana #> 2         2 Perry  Adele  Grande #> 3         3 a      d      g      #> 4         4 b      e      h      #> 5         5 c      f      i      y <- merge_rows(x, 1:2, chr) rectify(y) #> # A tibble: 5 × 4 #>   `row/col` `1(A)`     `2(B)` `3(C)`        #>       <dbl> <chr>      <chr>  <chr>         #> 1         1 Katy Perry Adele  Ariana Grande #> 2         2 NA         NA     NA            #> 3         3 a          d      g             #> 4         4 b          e      h             #> 5         5 c          f      i             z <- merge_cols(x, 1:2, chr) rectify(z) #> # A tibble: 5 × 4 #>   `row/col` `1(A)`      `2(B)` `3(C)` #>       <dbl> <chr>       <lgl>  <chr>  #> 1         1 Katy        NA     Ariana #> 2         2 Perry Adele NA     Grande #> 3         3 a d         NA     g      #> 4         4 b e         NA     h      #> 5         5 c f         NA     i"},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":null,"dir":"Reference","previous_headings":"","what":"Pack cell values from separate columns per data type into one list-column — pack","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"Pack cell values separate columns per data type one list-column","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"","code":"pack(   cells,   types = data_type,   name = \"value\",   drop_types = TRUE,   drop_type_cols = TRUE )  unpack(cells, values = value, name = \"data_type\", drop_packed = TRUE)"},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"cells data frame cells, one row per cell.  pack() must column names, cell/row, columns value .  unpack() must list-column cell values, element named according data type value. types pack(), name column names, cell/row, columns value . name string. pack(), name give new list-column values.  unpack(), name give new column name, cell, columns value . drop_types pack(), whether drop column named types. drop_type_cols pack(), whether drop original columns cell values. values unpack(), name list-column cell values. drop_packed unpack(), whether drop column named values.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"cells represented rows data frame, values cells different columns according data type.  example, value cell containing text column called chr (character came via tidyxl).  column called data_type names, cell, column value . pack() rearranges cell values different way, one column, taking cell value, whichever column. making element list. naming element according column came . making list new list-column original data frame. default, original columns dropped, data_type column. unpack() complement. can useful dropping columns cells except ones contain data.  example, tidyxl::xlsx_cells() returns wide data frame, make narrow might :   know advance data types need character, numeric date?  might also need logical error. Instead, pack() data types single column, select , unpack.","code":"select(cells, row, col, character, numeric, date) pack(cells) %>%   select(row, col, value) %>%   unpack()"},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"unpack(): Unpack cell values one list-column separate columns per data type","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/pack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pack cell values from separate columns per data type into one list-column — pack","text":"","code":"# A normal data frame w <- data.frame(foo = 1:2,                 bar = c(\"a\", \"b\"),                 stringsAsFactors = FALSE) w #>   foo bar #> 1   1   a #> 2   2   b  # The same data, represented by one row per cell, with integer values in the # `int` column and character values in the `chr` column. x <- as_cells(w) x #> # A tibble: 4 × 5 #>     row   col data_type chr     int #>   <int> <int> <chr>     <chr> <int> #> 1     1     1 int       NA        1 #> 2     2     1 int       NA        2 #> 3     1     2 chr       a        NA #> 4     2     2 chr       b        NA  # pack() and unpack() are complements pack(x) #> # A tibble: 4 × 3 #>     row   col value        #>   <int> <int> <named list> #> 1     1     1 <int [1]>    #> 2     2     1 <int [1]>    #> 3     1     2 <chr [1]>    #> 4     2     2 <chr [1]>    unpack(pack(x)) #> # A tibble: 4 × 5 #>     row   col data_type chr     int #>   <int> <int> <chr>     <chr> <int> #> 1     1     1 int       NA        1 #> 2     2     1 int       NA        2 #> 3     1     2 chr       a        NA #> 4     2     2 chr       b        NA  # Drop non-data columns from a wide data frame of cells from tidyxl if (require(tidyxl)) {   cells <- tidyxl::xlsx_cells(system.file(\"extdata\", \"purpose.xlsx\", package = \"unpivotr\"))   cells    pack(cells) %>%     dplyr::select(row, col, value) %>%     unpack() } #> Loading required package: tidyxl #> # A tibble: 1,721 × 7 #>      row   col data_type blank character                           error numeric #>    <int> <int> <chr>     <lgl> <chr>                               <chr>   <dbl> #>  1     1     1 character NA    The data is 'Sense of purpose by h… NA         NA #>  2     2     1 character NA    It can be found in the section 'Pe… NA         NA #>  3     3     1 character NA    The description provided by Statis… NA         NA #>  4     5     1 character NA    The 2014 New Zealand General Socia… NA         NA #>  5     6     1 character NA    It provides new and redeveloped da… NA         NA #>  6     7     1 character NA    Symbols used in this table:         NA         NA #>  7     8     1 character NA    S - Data has been suppressed.       NA         NA #>  8     9     1 character NA    * - Relative sampling error of 50 … NA         NA #>  9    10     1 character NA    For more tables using the NZGSS 20… NA         NA #> 10    11     1 character NA    Data quality                        NA         NA #> # ℹ 1,711 more rows"},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":null,"dir":"Reference","previous_headings":"","what":"Divide a grid of cells into partitions containing individual tables — partition","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"Given positions corner cells mark individual tables single spreadsheet, partion() works table cells belong corner cells.  individual tables can worked independently. partition() partitions along dimensions (rows columns) . partition_dim() partitions along one dimension time.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"","code":"partition(cells, corners, align = \"top_left\", nest = TRUE, strict = TRUE)  partition_dim(positions, cutpoints, bound = \"upper\")"},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"cells Data frame tbl, cells partitioned, as_cells() tidyxl::xlsx_cells(). corners usually subset cells, corners individual tables.  Can also cells among cells, case see strict argument. align Character, position corner cells relative tables, one \"top_left\" (default), \"top_right\", \"bottom_left\", \"bottom_right\". nest Logical, whether nest partitions list-column data frames. strict Logical, whether omit partitions contain corner cell. positions Integer vector, positions cells (either row position column position), grouped cutpoints. cutpoints Integer vector. positions separated groups either side cutpoint. bound One \"upper\" \"lower\", controls whether cells lie cutpoint grouped cells cutpoint. example, column 5 cutpoint, cell column 5, \"lower\" group cells columns 1 4, whereas \"upper\" group cells columns 6 10.  can use cells bottom right-hand side table cutpoints (either 'upper' bounds row column numbers count 1 top-left row column).  \"upper\", cell_positions first cutpoint group 0; \"lower\", cell_positions final cutpoint 0.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"partition_dim() returns integer vector, numbering groups cells.  Group 0 represents cells first cutpoint (bound = \"upper\"), first cutpoint (bound = \"lower\").  groups numbered 1, group 1 adjacent group 0. partition_dim() returns integer vector, numbering groups cells. Group 0 represents cells first cutpoint (bound = \"upper\"), first cutpoint (bound = \"lower\").  groups numbered 1, group 1 adjacent group 0.  Divide grid cells chunks along dimensions","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"partition_dim(): Divide grid cells chunks along one dimension","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/partition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divide a grid of cells into partitions containing individual tables — partition","text":"","code":"# The `purpose` dataset, represented in four summary tables multiples <- purpose$small_multiples rectify(multiples, character, numeric) #> # A tibble: 14 × 6 #>    `row/col` `1(A)`                     `2(B)` `3(C)` `4(D)`            `5(E)` #>        <int> <chr>                      <chr>  <chr>  <chr>             <chr>  #>  1         1 Postgraduate qualification NA     NA     Bachelor's degree NA     #>  2         2 Sex                        Value  NA     Sex               Value  #>  3         3 Female                     NA     NA     Female            NA     #>  4         4 Male                       NA     NA     Male              NA     #>  5         5 NA                         NA     NA     NA                NA     #>  6         6 Diploma                    NA     NA     Certificate       NA     #>  7         7 Sex                        Value  NA     Sex               Value  #>  8         8 Female                     NA     NA     Female            NA     #>  9         9 Male                       NA     NA     Male              NA     #> 10        10 NA                         NA     NA     NA                NA     #> 11        11 No Qualification           NA     NA     NA                NA     #> 12        12 Sex                        Value  NA     NA                NA     #> 13        13 Female                     NA     NA     NA                NA     #> 14        14 Male                       NA     NA     NA                NA      # The same thing in its raw 'melted' form that can be filtered multiples #>    row col data_type                  character numeric #> 1    1   1 character Postgraduate qualification      NA #> 2    1   2     blank                       <NA>      NA #> 3    1   4 character          Bachelor's degree      NA #> 4    1   5     blank                       <NA>      NA #> 5    2   1 character                        Sex      NA #> 6    2   2 character                      Value      NA #> 7    2   4 character                        Sex      NA #> 8    2   5 character                      Value      NA #> 9    3   1 character                     Female      NA #> 10   3   2   numeric                       <NA>  171000 #> 11   3   4 character                     Female      NA #> 12   3   5   numeric                       <NA>  275000 #> 13   4   1 character                       Male      NA #> 14   4   2   numeric                       <NA>  159000 #> 15   4   4 character                       Male      NA #> 16   4   5   numeric                       <NA>  200000 #> 17   6   1 character                    Diploma      NA #> 18   6   2     blank                       <NA>      NA #> 19   6   4 character                Certificate      NA #> 20   6   5     blank                       <NA>      NA #> 21   7   1 character                        Sex      NA #> 22   7   2 character                      Value      NA #> 23   7   4 character                        Sex      NA #> 24   7   5 character                      Value      NA #> 25   8   1 character                     Female      NA #> 26   8   2   numeric                       <NA>  210000 #> 27   8   4 character                     Female      NA #> 28   8   5   numeric                       <NA>  732000 #> 29   9   1 character                       Male      NA #> 30   9   2   numeric                       <NA>  173000 #> 31   9   4 character                       Male      NA #> 32   9   5   numeric                       <NA>  807000 #> 33  11   1 character           No Qualification      NA #> 34  11   2     blank                       <NA>      NA #> 35  12   1 character                        Sex      NA #> 36  12   2 character                      Value      NA #> 37  13   1 character                     Female      NA #> 38  13   2   numeric                       <NA>  344000 #> 39  14   1 character                       Male      NA #> 40  14   2   numeric                       <NA>  287000  # First, find the cells that mark a corner of each table corners <-   dplyr::filter(multiples,                 !is.na(character),                 !(character %in% c(\"Sex\", \"Value\", \"Female\", \"Male\")))  # Then find out which cells fall into which partition partition(multiples, corners) #> # A tibble: 5 × 6 #>   corner_row corner_col cells            data_type character             numeric #>        <dbl>      <dbl> <list>           <chr>     <chr>                   <dbl> #> 1          1          1 <tibble [8 × 5]> character Postgraduate qualifi…      NA #> 2          1          4 <tibble [8 × 5]> character Bachelor's degree          NA #> 3          6          1 <tibble [8 × 5]> character Diploma                    NA #> 4          6          4 <tibble [8 × 5]> character Certificate                NA #> 5         11          1 <tibble [8 × 5]> character No Qualification           NA  # You can also use bottom-left corners (or top-right or bottom-right) bl_corners <- dplyr::filter(multiples, character == \"Male\") partition(multiples, bl_corners, align = \"bottom_left\") #> # A tibble: 5 × 6 #>   corner_row corner_col cells            data_type character numeric #>        <dbl>      <dbl> <list>           <chr>     <chr>       <dbl> #> 1          4          1 <tibble [8 × 5]> character Male           NA #> 2          4          4 <tibble [8 × 5]> character Male           NA #> 3          9          1 <tibble [8 × 5]> character Male           NA #> 4          9          4 <tibble [8 × 5]> character Male           NA #> 5         14          1 <tibble [8 × 5]> character Male           NA  # To complete the grid even when not all corners are supplied, use `strict` bl_corners <- bl_corners[-1, ] partition(multiples, bl_corners, align = \"bottom_left\") #> # A tibble: 4 × 6 #>   corner_row corner_col cells            data_type character numeric #>        <dbl>      <dbl> <list>           <chr>     <chr>       <dbl> #> 1          4          4 <tibble [8 × 5]> character Male           NA #> 2          9          1 <tibble [8 × 5]> character Male           NA #> 3          9          4 <tibble [8 × 5]> character Male           NA #> 4         14          1 <tibble [8 × 5]> character Male           NA partition(multiples, bl_corners, align = \"bottom_left\", strict = FALSE) #> # A tibble: 4 × 6 #>   corner_row corner_col cells            data_type character numeric #>        <dbl>      <dbl> <list>           <chr>     <chr>       <dbl> #> 1          4          4 <tibble [8 × 5]> character Male           NA #> 2          9          1 <tibble [8 × 5]> character Male           NA #> 3          9          4 <tibble [8 × 5]> character Male           NA #> 4         14          1 <tibble [8 × 5]> character Male           NA # Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and 7th # rows. partition_dim(1:10, c(3, 5, 7)) #>  [1] NA NA  3  3  5  5  7  7  7  7  # Given a set of cells in columns 1 to 10, partition them at the 3rd, 5th and # 7th column.  This example is exactly the same as the previous one, to show # that the function works the same way on columns as rows. partition_dim(1:10, c(3, 5, 7)) #>  [1] NA NA  3  3  5  5  7  7  7  7  # Given a set of cells in rows 1 to 10, partition them at the 3rd, 5th and # 7th rows, aligned to the bottom of the group. partition_dim(1:10, c(3, 5, 7), bound = \"lower\") #>  [1]  3  3  3  5  5  7  7 NA NA NA  # Non-integer row/column numbers and cutpoints can be used, even though they # make no sense in the context of partioning grids of cells.  They are # rounded towards zero first. partition_dim(1:10 - .5, c(3, 5, 7)) #>  [1] NA NA NA  3  3  5  5  7  7  7 partition_dim(1:10, c(3, 5, 7) + 1.5) #>  [1] NA NA NA NA  4  4  6  6  8  8"},{"path":"https://nacnudus.github.io/unpivotr/reference/purpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","title":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","text":"dataset containing self-rated sense--purpose respondents 2014 New Zealand General Social Survey.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/purpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","text":"","code":"purpose"},{"path":"https://nacnudus.github.io/unpivotr/reference/purpose.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","text":"list eight data frames.  first data frame, Tidy, contains raw data standard tabular format: Sex Character, two levels Age group (Life-stages) Character, age-range years, four levels Highest qualification Character, five levels Sense purpose Character, score-range, two levels NA Value Numeric, number respondents (weighted? rounded?), NAs Flags Character, metadata flags, two levels NA next six data frames pivot tables first data frame.  data frames named compass directions suggested unpivoting . final data frame 'tidy' representation small-multiple pivot tables.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/purpose.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","text":"data 'Sense purpose highest qualification, age group, sex, 2014' Statistics New Zealand portal NZ.Stat, retrieved 2016-08-19.  found section 'People communities', 'Self-rated well-(NZGSS)'.  data exported Excel (.xlsx) file format available 'extdata/purpose.xlsx' package directory.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/purpose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sense-of-purpose in the 2014 New Zealand General Social Survey — purpose","text":"description provided Statistics New Zealand . \"2014 New Zealand General Social Survey (NZGSS) fourth survey series. run NZGSS every two years interview around 8,500 people range social economic outcomes. provides new redeveloped data different aspects people's lives well-. particular, survey provides view well-outcomes distributed across different groups within New Zealand population. Symbols used table: S Data suppressed. * Relative sampling error 50 percent . Numbers may add total 'know' 'Refused' excluded. Data quality: statistics produced accordance Official Statistics System principles protocols quality. conform Statistics NZ Methodological Standard Reporting Data Quality.\"","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/rectify.html","id":null,"dir":"Reference","previous_headings":"","what":"Display cells as though in a spreadsheet — rectify","title":"Display cells as though in a spreadsheet — rectify","text":"Takes 'melted' output as_cells() tidyxl::xlsx_cells() (row represents one cell) projects cells original positions.  default prints terminal/console, display = \"browser\" display = \"rstudio\" displayed browser RStudio viewer pane. viewing ; output designed used functions. Example: following cells   presented   letters column names comparing view spreadsheet application.","code":"row col value   1   1   \"a\"   1   2   \"b\"   2   1   \"c\"   2   2   \"d\" row/col 1(A) 2(B)       1 \"a\"  \"b\"       2 \"c\"  \"d\""},{"path":"https://nacnudus.github.io/unpivotr/reference/rectify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display cells as though in a spreadsheet — rectify","text":"","code":"rectify(cells, values = NULL, types = data_type, formatters = list())  # S3 method for class 'cell_grid' print(x, display = \"terminal\", ...)"},{"path":"https://nacnudus.github.io/unpivotr/reference/rectify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display cells as though in a spreadsheet — rectify","text":"cells Data frame tbl, cells displayed. values Optional. column cells use values cell.  Given bare variable name.  omitted (default), types argument used instead. types column cells names, cell, column use value cell.  E.g.  cell character value \"character\" column. formatters named list functions format cell values display, named according column cell value . x output rectify() display One \"terminal\" (default), \"browser\", \"rstudio\".  display browser must DT package installed. ... Arguments passed print()","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/rectify.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Display cells as though in a spreadsheet — rectify","text":"print(cell_grid): S3 method class cell_grid","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/rectify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display cells as though in a spreadsheet — rectify","text":"","code":"x <- data.frame(name = c(\"Matilda\", \"Nicholas\"),                 score = c(14L, 10L),                 stringsAsFactors = FALSE)  # This is the original form of the table, which is easy to read. x #>       name score #> 1  Matilda    14 #> 2 Nicholas    10  # This is the 'tidy' arrangement that is difficult for humans to read (but # easy for computers) y <- as_cells(x, col_names = TRUE) y #> # A tibble: 6 × 5 #>     row   col data_type chr        int #>   <int> <int> <chr>     <chr>    <int> #> 1     1     1 chr       name        NA #> 2     2     1 chr       Matilda     NA #> 3     3     1 chr       Nicholas    NA #> 4     1     2 chr       score       NA #> 5     2     2 int       NA          14 #> 6     3     2 int       NA          10  # rectify() projects the cells as a spreadsheet again, for humans to read. rectify(y) #> # A tibble: 3 × 3 #>   `row/col` `1(A)`   `2(B)` #>       <int> <chr>    <chr>  #> 1         1 name     score  #> 2         2 Matilda  14     #> 3         3 Nicholas 10      # You can choose to use a particular column of the data rectify(y, values = chr) #> # A tibble: 3 × 3 #>   `row/col` `1(A)`   `2(B)` #>       <int> <chr>    <chr>  #> 1         1 name     score  #> 2         2 Matilda  NA     #> 3         3 Nicholas NA     rectify(y, values = int) #> # A tibble: 3 × 3 #>   `row/col` `1(A)` `2(B)` #>       <int>  <int>  <int> #> 1         1     NA     NA #> 2         2     NA     14 #> 3         3     NA     10  # You can also show which row or which column each cell came from, which # helps with understanding what this function does. rectify(y, values = row) #> # A tibble: 3 × 3 #>   `row/col` `1(A)` `2(B)` #>       <int>  <int>  <int> #> 1         1      1      1 #> 2         2      2      2 #> 3         3      3      3 rectify(y, values = col) #> # A tibble: 3 × 3 #>   `row/col` `1(A)` `2(B)` #>       <int>  <int>  <int> #> 1         1      1      2 #> 2         2      1      2 #> 3         3      1      2  # Empty rows and columns up to the first occupied cell are dropped, but the # row and column names reflect the original row and column numbers. y$row <- y$row + 5 y$col <- y$col + 5 rectify(y) #> # A tibble: 3 × 3 #>   `row/col` `6(F)`   `7(G)` #>       <dbl> <chr>    <chr>  #> 1         6 name     score  #> 2         7 Matilda  14     #> 3         8 Nicholas 10      # Supply named functions to format cell values for display. rectify(y, formatters = list(chr = toupper, int = ~ . * 10)) #> # A tibble: 3 × 3 #>   `row/col` `6(F)`   `7(G)` #>       <dbl> <chr>    <chr>  #> 1         6 NAME     SCORE  #> 2         7 MATILDA  140    #> 3         8 NICHOLAS 100    # # Print in the browser or in the RStudio viewer pane if (FALSE) { # \\dontrun{   z <- rectify(y)   print(z, \"browser\")   print(z, \"rstudio\") } # }"},{"path":"https://nacnudus.github.io/unpivotr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. magrittr %>%","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/spatter.html","id":null,"dir":"Reference","previous_headings":"","what":"Spread key-value pairs of mixed types across multiple columns — spatter","title":"Spread key-value pairs of mixed types across multiple columns — spatter","text":"spatter() like tidyr::spread() different columns different data types.  works data come via as_cells() tidyxl::xlsx_cells(), row represents one cell table, value cell represented different column, depending data type.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/spatter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spread key-value pairs of mixed types across multiple columns — spatter","text":"","code":"spatter(cells, key, values = NULL, types = data_type, formatters = list())"},{"path":"https://nacnudus.github.io/unpivotr/reference/spatter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spread key-value pairs of mixed types across multiple columns — spatter","text":"cells data frame row represents cell, columns row col, usually column data_type, additional columns cell values. key name column whose values become column names values Optional. column cells use value cell.  Given bare variable name.  omitted (default), type argument used instead. types Optional. column names, row cells, column contains cell value.  Defaults data_type. formatters named list functions formatting particular data types, named data type (name column cells contains cell value.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/spatter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spread key-value pairs of mixed types across multiple columns — spatter","text":"","code":"# A tidy representation of cells of mixed data types x <- data.frame(stringsAsFactors = FALSE,         row = c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L),         col = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L),   data_type = c(\"character\", \"character\", \"character\", \"numeric\", \"character\",                 \"numeric\", \"character\", \"numeric\"),   character = c(\"Name\", \"Age\", \"Matilda\", NA, \"Nicholas\", NA, \"Olivia\", NA),     numeric = c(NA, NA, NA, 1, NA, 3, NA, 5)) x #>   row col data_type character numeric #> 1   1   1 character      Name      NA #> 2   1   2 character       Age      NA #> 3   2   1 character   Matilda      NA #> 4   2   2   numeric      <NA>       1 #> 5   3   1 character  Nicholas      NA #> 6   3   2   numeric      <NA>       3 #> 7   4   1 character    Olivia      NA #> 8   4   2   numeric      <NA>       5  # How it would look in a spreadsheet rectify(x) #> # A tibble: 4 × 3 #>   `row/col` `1(A)`   `2(B)` #>       <int> <chr>    <chr>  #> 1         1 Name     Age    #> 2         2 Matilda  1      #> 3         3 Nicholas 3      #> 4         4 Olivia   5       # How it looks after treating the cells in row 1 as headers y <- behead(x, \"N\", header) y$col <- NULL # Drop the 'col' column y #> # A tibble: 6 × 5 #>     row data_type character numeric header #>   <int> <chr>     <chr>       <dbl> <chr>  #> 1     2 character Matilda        NA Name   #> 2     2 numeric   NA              1 Age    #> 3     3 character Nicholas       NA Name   #> 4     3 numeric   NA              3 Age    #> 5     4 character Olivia         NA Name   #> 6     4 numeric   NA              5 Age     # At this point you might want to do tidyr::spread(), but it won't work because # you want to use both the `character` and `numeric` columns as the values. tidyr::spread(y, header, numeric) #> # A tibble: 6 × 5 #>     row data_type character   Age  Name #>   <int> <chr>     <chr>     <dbl> <dbl> #> 1     2 character Matilda      NA    NA #> 2     2 numeric   NA            1    NA #> 3     3 character Nicholas     NA    NA #> 4     3 numeric   NA            3    NA #> 5     4 character Olivia       NA    NA #> 6     4 numeric   NA            5    NA tidyr::spread(y, header, character) #> # A tibble: 6 × 5 #>     row data_type numeric Age   Name     #>   <int> <chr>       <dbl> <chr> <chr>    #> 1     2 character      NA NA    Matilda  #> 2     2 numeric         1 NA    NA       #> 3     3 character      NA NA    Nicholas #> 4     3 numeric         3 NA    NA       #> 5     4 character      NA NA    Olivia   #> 6     4 numeric         5 NA    NA       spatter(y, header) #> # A tibble: 3 × 3 #>     row   Age Name     #>   <int> <dbl> <chr>    #> 1     2     1 Matilda  #> 2     3     3 Nicholas #> 3     4     5 Olivia    # The difference between spatter() and tidyr::spread() is that spatter() # needs to know which data-type to use for each cell beneath the headers.  By # default, it looks at the `data_type` column to decide, but you can change # that with the `types` argument. y %>%   dplyr::select(-data_type, -numeric) %>%   dplyr::mutate(data_type_2 = \"character\") %>%   spatter(header, types = data_type_2) #> # A tibble: 3 × 3 #>     row Age   Name     #>   <int> <chr> <chr>    #> 1     2 NA    Matilda  #> 2     3 NA    Nicholas #> 3     4 NA    Olivia    # Alternatively you can name one specific column to use for the cell values. y %>%   dplyr::mutate(foo = letters[1:6]) %>%   dplyr::select(header, row, foo) %>%   spatter(header, values = foo) #> # A tibble: 3 × 3 #>     row Age   Name  #>   <int> <chr> <chr> #> 1     2 b     a     #> 2     3 d     c     #> 3     4 f     e      # The column used for the values is consumed before the spread occurs. If # it's necessary for demarking the rows, then make a copy of it first, # otherwise you'll get an error like \"Duplicate identifiers for rows ...\" y %>%   dplyr::mutate(row2 = row) %>%   dplyr::select(row, header, row2) %>%   spatter(header, values = row2) #> # A tibble: 3 × 3 #>     row   Age  Name #>   <int> <int> <int> #> 1     2     2     2 #> 2     3     3     3 #> 3     4     4     4  # Like tidyr::spread(), you need to discard extraneous columns beforehand. # Otherwise you can get more rows out than you want. y$extra <- 11:16 spatter(y, header) #> # A tibble: 6 × 4 #>     row extra   Age Name     #>   <int> <int> <dbl> <chr>    #> 1     2    11    NA Matilda  #> 2     2    12     1 NA       #> 3     3    13    NA Nicholas #> 4     3    14     3 NA       #> 5     4    15    NA Olivia   #> 6     4    16     5 NA        # pack() is an easy way to keep just the columns you need, without knowing # in advance which data-type columns you need.  This examples adds a new # column, which is then removed by the pack-unpack sequence without having to # mention it by name. x$extra <- 11:18 x %>%   pack() %>%   dplyr::select(row, col, value) %>%   unpack() #>   row col data_type character numeric #> 1   1   1 character      Name      NA #> 2   1   2 character       Age      NA #> 3   2   1 character   Matilda      NA #> 4   2   2   numeric      <NA>       1 #> 5   3   1 character  Nicholas      NA #> 6   3   2   numeric      <NA>       3 #> 7   4   1 character    Olivia      NA #> 8   4   2   numeric      <NA>       5  # spatter() automatically converts data types so that they can coexist in the # same column.  Ordered factors in particular will always be coerced to # unordered factors.  # You can control data type conversion by supplying custom functions, named # by the data type of the cells they are to convert (look at the `data_type` # column).  If your custom functions aren't sufficient to avoid the need for # coercion, then they will be overridden. spatter(y, header,         formatters = list(character = ~ toupper(.), numeric = as.complex)) #> # A tibble: 6 × 4 #>     row extra Age   Name     #>   <int> <int> <cpl> <chr>    #> 1     2    11   NA  MATILDA  #> 2     2    12 1+0i  NA       #> 3     3    13   NA  NICHOLAS #> 4     3    14 3+0i  NA       #> 5     4    15   NA  OLIVIA   #> 6     4    16 5+0i  NA"},{"path":"https://nacnudus.github.io/unpivotr/reference/tidy_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Tokenize data frames into a tidy 'melted' structure — tidy_table","title":"Tokenize data frames into a tidy 'melted' structure — tidy_table","text":"tidy_table() deprecated.  Use as_cells() instead. certain non-rectangular data formats, can useful parse data melted format row represents single token. Data frames represent data tabular structure.  tidy_table takes row column position 'cell', returns information new data frame, alongside content type cell. makes easier deal complex non-tabular data (e.g. pivot tables) imported R data frames.  'melted' tidy_table(), can use functions like behead() spatter() reshape conventional, tidy, unpivoted structures. HTML tables, content cell returned standalone HTML string can parsed tools rvest package.  particularly useful HTML cell contains HTML table, contains text URL.  HTML poorly formatted, try passing htmltidy package first. S3 generic.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/tidy_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tokenize data frames into a tidy 'melted' structure — tidy_table","text":"","code":"tidy_table(x, row_names = FALSE, col_names = FALSE)"},{"path":"https://nacnudus.github.io/unpivotr/reference/tidy_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tokenize data frames into a tidy 'melted' structure — tidy_table","text":"x data.frame HTML document row_names Whether treat row names cells, Default: FALSE col_names Whether treat column names  cells, Default: FALSE","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/tidy_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tokenize data frames into a tidy 'melted' structure — tidy_table","text":"data.frame following columns: row col (integer) giving original position 'cells' relevant columns cell values original types: chr, cpl, dbl, fct, int, lgl, list, ord data_type specify cell columns (chr etc.) value . columns fct ord , like list, list-columns (element independent) avoid factor levels clashing.  HTML tables, column html gives HTML string original cell. Row column names, present required row_names = TRUE col_names = TRUE, treated though cells table, appear chr column.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/tidy_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tokenize data frames into a tidy 'melted' structure — tidy_table","text":"","code":"x <- data.frame(a = c(10, 20),                 b = c(\"foo\", \"bar\"),                 stringsAsFactors = FALSE) x #>    a   b #> 1 10 foo #> 2 20 bar tidy_table(x) #> tidy_table() will be deprecated.  Use as_cells() instead. #> # A tibble: 4 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 dbl       NA       10 #> 2     2     1 dbl       NA       20 #> 3     1     2 chr       foo      NA #> 4     2     2 chr       bar      NA tidy_table(x, row_names = TRUE) #> tidy_table() will be deprecated.  Use as_cells() instead. #> # A tibble: 6 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 chr       1        NA #> 2     2     1 chr       2        NA #> 3     1     2 dbl       NA       10 #> 4     2     2 dbl       NA       20 #> 5     1     3 chr       foo      NA #> 6     2     3 chr       bar      NA tidy_table(x, col_names = TRUE) #> tidy_table() will be deprecated.  Use as_cells() instead. #> # A tibble: 6 × 5 #>     row   col data_type chr     dbl #>   <int> <int> <chr>     <chr> <dbl> #> 1     1     1 chr       a        NA #> 2     2     1 dbl       NA       10 #> 3     3     1 dbl       NA       20 #> 4     1     2 chr       b        NA #> 5     2     2 chr       foo      NA #> 6     3     2 chr       bar      NA  # 'list' columns are undisturbed y <- data.frame(a = c(\"a\", \"b\"), stringsAsFactors = FALSE) y$b <- list(1:2, 3:4) y #>   a    b #> 1 a 1, 2 #> 2 b 3, 4 tidy_table(y) #> tidy_table() will be deprecated.  Use as_cells() instead. #> # A tibble: 4 × 5 #>     row   col data_type chr   list      #>   <int> <int> <chr>     <chr> <list>    #> 1     1     1 chr       a     <NULL>    #> 2     2     1 chr       b     <NULL>    #> 3     1     2 list      NA    <int [2]> #> 4     2     2 list      NA    <int [2]>  # Factors are preserved by being wrapped in lists so that their levels don't # conflict.  Blanks are NULLs. z <- data.frame(x = factor(c(\"a\", \"b\")),                 y = factor(c(\"c\", \"d\"), ordered = TRUE)) tidy_table(z) #> tidy_table() will be deprecated.  Use as_cells() instead. #> # A tibble: 4 × 5 #>     row   col data_type fct       ord       #>   <int> <int> <chr>     <list>    <list>    #> 1     1     1 fct       <fct [1]> <NULL>    #> 2     2     1 fct       <fct [1]> <NULL>    #> 3     1     2 ord       <NULL>    <ord [1]> #> 4     2     2 ord       <NULL>    <ord [1]> tidy_table(z)$fct #> tidy_table() will be deprecated.  Use as_cells() instead. #> [[1]] #> [1] a #> Levels: a b #>  #> [[2]] #> [1] b #> Levels: a b #>  #> [[3]] #> NULL #>  #> [[4]] #> NULL #>  tidy_table(z)$ord #> tidy_table() will be deprecated.  Use as_cells() instead. #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> [1] c #> Levels: c < d #>  #> [[4]] #> [1] d #> Levels: c < d #>   # HTML tables can be extracted from the output of xml2::read_html().  These # are returned as a list of tables, similar to rvest::html_table().  The # value of each cell is its standalone HTML string, which can contain # anything -- even another table.  colspan <- system.file(\"extdata\", \"colspan.html\", package = \"unpivotr\") rowspan <- system.file(\"extdata\", \"rowspan.html\", package = \"unpivotr\") nested <- system.file(\"extdata\", \"nested.html\", package = \"unpivotr\")  if (FALSE) { # \\dontrun{ browseURL(colspan) browseURL(rowspan) browseURL(nestedspan) } # }  tidy_table(xml2::read_html(colspan)) #> tidy_table() will be deprecated.  Use as_cells() instead. #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                     #>   <int> <int> <chr>     <chr>                                    #> 1     1     1 html      \"<th colspan=\\\"2\\\">Header (1, 1:2)<\/th>\" #> 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                   #> 3     1     2 html       NA                                      #> 4     2     2 html      \"<td>cell (2, 2)<\/td>\"                   #>  tidy_table(xml2::read_html(rowspan)) #> tidy_table() will be deprecated.  Use as_cells() instead. #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                     #>   <int> <int> <chr>     <chr>                                    #> 1     1     1 html      \"<th rowspan=\\\"2\\\">Header (1:2, 1)<\/th>\" #> 2     2     1 html       NA                                      #> 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                 #> 4     2     2 html      \"<td>cell (2, 2)<\/td>\"                   #>  tidy_table(xml2::read_html(nested)) #> tidy_table() will be deprecated.  Use as_cells() instead. #> [[1]] #> # A tibble: 4 × 4 #>     row   col data_type html                                                     #>   <int> <int> <chr>     <chr>                                                    #> 1     1     1 html      \"<th>Header (1, 1)<\/th>\"                                 #> 2     2     1 html      \"<td>cell (2, 1)<\/td>\"                                   #> 3     1     2 html      \"<th>Header (1, 2)<\/th>\"                                 #> 4     2     2 html      \"<td>\\n          <table>\\n<tr>\\n<th>Header (2, 2)(1, 1)… #>"},{"path":"https://nacnudus.github.io/unpivotr/reference/unpivotr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Un-pivot complex and irregular data layouts. — unpivotr-package","title":"Un-pivot complex and irregular data layouts. — unpivotr-package","text":"'Unpivotr' provides tools converting data complex irregular layouts columnar structure.  example, tables multi-level column row headers, spreadsheets several tables, nested HTML tables, data uses several different sentinel values.","code":""},{"path":"https://nacnudus.github.io/unpivotr/reference/unpivotr-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Un-pivot complex and irregular data layouts. — unpivotr-package","text":"best way learn unpivotr free online book Spreadsheet Munging Strategies. Header data cells can selected contents, position, data type formatting, can associated one relative positions. input data must data frame columns 'row' 'col' describe position 'cell' data.  cells interpreted data, columns containing 'value' cell , course, necessary point using package, though actually required given functions. Data frames HTML tables can converted format meeting requirements using as_cells() function.  Excel (.xlsx) files can imported directly required format 'tidyxl' package, available https://github.com/nacnudus/tidyxl, advantage retains cell formatting comments.","code":""},{"path":[]},{"path":"https://nacnudus.github.io/unpivotr/reference/unpivotr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Un-pivot complex and irregular data layouts. — unpivotr-package","text":"Maintainer: Duncan Garmonsway nacnudus@gmail.com","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-064","dir":"Changelog","previous_headings":"","what":"unpivotr 0.6.4","title":"unpivotr 0.6.4","text":"CRAN release: 2024-11-30 Make tests compatible recent versions tzdata (CRAN)","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-063","dir":"Changelog","previous_headings":"","what":"unpivotr 0.6.3","title":"unpivotr 0.6.3","text":"CRAN release: 2023-01-22 Make compatible dplyr v1.1.0 (#58 @DavisVaughan) Implement as_cells.matrix() (#52 @billdenney) Allow behead() work grouped data (#46 @billdenney) Add as_cells.matrix (#41 @billdenney)","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-062","dir":"Changelog","previous_headings":"","what":"unpivotr 0.6.2","title":"unpivotr 0.6.2","text":"CRAN release: 2021-08-22 Fix upstream changes rlang (#49 thanks @lionel-)","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-061","dir":"Changelog","previous_headings":"","what":"unpivotr 0.6.1","title":"unpivotr 0.6.1","text":"CRAN release: 2020-08-03 Fix concatenation NULL POSIXct (dates) (#39 @romainfrancois)","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-060","dir":"Changelog","previous_headings":"","what":"unpivotr 0.6.0","title":"unpivotr 0.6.0","text":"CRAN release: 2020-05-08 Change \"NNW\" \"-left\" etc. Compass directions still work, built-dataset purpose different names documentation gradually change new terms. Patches upcoming upstream changes","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-051","dir":"Changelog","previous_headings":"","what":"unpivotr 0.5.1","title":"unpivotr 0.5.1","text":"CRAN release: 2019-03-30 Patch tibble .name_repair compatibility (#2144 @krlmlr) Patch switch tidyselect dplyr functions.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-050","dir":"Changelog","previous_headings":"","what":"unpivotr 0.5.0","title":"unpivotr 0.5.0","text":"CRAN release: 2019-01-02","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"unpivotr 0.5.0","text":"behead_if() tiered headers within row column. takes filter functions similarly dplyr::filter() decide cells treat headers, can applied row column headers every tier dealt . merge_rows() merge_cols() combines header text split multiple cells.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"other-changes-0-5-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"unpivotr 0.5.0","text":"behead(), enhead(), partition() rectify() give informative error message non-distinct cells, example trying pass cells one sheet functions (@gregrs-uk, #15).","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-040","dir":"Changelog","previous_headings":"","what":"unpivotr 0.4.0","title":"unpivotr 0.4.0","text":"CRAN release: 2018-06-26 version makes big breaking changes sake intuitive grammar. comes much documentation online book Spreadsheet Munging Strategies. main new workhorses: behead() takes one level headers pivot table make part data. Chain function gradually strip every level header away tidy data. spatter() data-type aware version tidyr::spread() common final step. partition() breaks small-multiples single sheet, can handle individually. rectify() visualises cells console look spreadsheet.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"breaking-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"unpivotr 0.4.0","text":"previous version can installed follows. family functions NNW() etc. removed favour verbose join_header(), renamed enhead() suggest similarity behead() (though complements). enhead() (formerly join_header() now follows tidyverse convention fct ‘factor’ ord ‘ordered factor’. enhead() (formerly join_header()) now uses col_names row_names arguments instead colnames rownames, consistency tidyr.","code":"devtools::install_version(\"unpivotr\", version = \"0.3.1\", repos = \"http://cran.us.r-project.org\")"},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"unpivotr 0.4.0","text":"behead() takes one level headers pivot table make part data. Think like tidyr::gather(), except works one row headers (one column row-headers), works tables first come enhead() (formerly join_header() tidyxl::xlsx_cells(). rectify() displays cells though spreadsheet, rather ‘melted’ form enhead() (formerly join_header()) tidyxl::xlsx_cells(). useful understanding structure pivot table human, planning unpivot . print method available render large datasets browser RStudio viewer pane. partition() divides grid cells partitions containing individual tables. Give corner cells table spreadsheet. pack() packs cells values separate columns per data type one list-column. unpack() complement. isolate_sentinels() move sentinel values separate column, leaving NA behind (NULL list-columns). spatter() like tidyr::spread(), preserves mixed data types. enhead() (formerly join_header()) now returns data_type column names column contains value cell, similar tidyxl::xlsx_cells(). enhead() (formerly join_header() now follows tidyverse convention fct ‘factor’ ord ‘ordered factor’. enhead() (formerly join_header()) gains drop = TRUE argument control whether discard cells don’t matching header (e.g. ones left leftmost header enhead(x, y, \"NNW\")). justify() moves one set cells positions another set. useful header cells aren’t corner cells describle. Put header cells justify(), along cells corner. New vignette ‘worked-examples’ common tasks munging spreadsheets. ‘small-multiples’ vignette refactored use new features. purpose (built-dataset) gains new list-member small-multiples.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"under-the-hood-0-4-0","dir":"Changelog","previous_headings":"","what":"Under the hood","title":"unpivotr 0.4.0","text":"longer depends data.table package.","code":""},{"path":[]},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-031","dir":"Changelog","previous_headings":"","what":"unpivotr 0.3.1","title":"unpivotr 0.3.1","text":"CRAN release: 2018-01-20 Performance improvements tidy_table(). Fixed CRAN test platforms.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-030","dir":"Changelog","previous_headings":"","what":"unpivotr 0.3.0","title":"unpivotr 0.3.0","text":"CRAN release: 2017-12-03 Made compatible tidyxl version 1.0.0 (avoids dplyr::distinct(), doesn’t handle list columns). Updated use new dplyr/rlang combination instead old dplyr/lazyeval one.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-021","dir":"Changelog","previous_headings":"","what":"unpivotr 0.2.1","title":"unpivotr 0.2.1","text":"CRAN release: 2017-07-02 release overhauls tidy_table() function unpivotr preserve original data types table cells support HTML tables. tidytable() renamed tidy_table(). tidytable() error, rather deprecation warning, tidy_table() different . new tidy_table() method vignette HTML. tidy_table() method matrices. Convert matrices data.frames first, choosing row column names. tidy_table() returns relevant columns, according data types columns given data frame. uses tibble::type_sum() determine column type name columns, whereas characters used returned column called character, now returned column called chr. full list column names ?tidy_table chr, cplx, cplx, dbl, fctr, int, lgl, list. columns fctr list list-columns, element list. means factors different levels kept separate. HTML tables, html column returned containing standalone HTML cell. rowname colname arguments tidy_table() now default FALSE. functions consistently return tibble. error messages helpful.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-011","dir":"Changelog","previous_headings":"","what":"unpivotr 0.1.1","title":"unpivotr 0.1.1","text":"CRAN release: 2017-04-23 Fixed breakages introduced dplyr 0.6.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-010","dir":"Changelog","previous_headings":"","what":"unpivotr 0.1.0","title":"unpivotr 0.1.0","text":"CRAN release: 2017-01-31 Moved images inst/extdata vignettes.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-010-1","dir":"Changelog","previous_headings":"","what":"unpivotr 0.1.0","title":"unpivotr 0.1.0","text":"CRAN release: 2017-01-31 Bumped version match tidyxl, now mature. Updated README vignettes use new tidyxl api.","code":""},{"path":"https://nacnudus.github.io/unpivotr/news/index.html","id":"unpivotr-0009000","dir":"Changelog","previous_headings":"","what":"unpivotr 0.0.0.9000","title":"unpivotr 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
